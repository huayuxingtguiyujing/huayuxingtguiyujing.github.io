<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>记录游戏开发历程</title>

  
  <meta name="author" content="Nobody">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="记录游戏开发历程"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="记录游戏开发历程" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">记录游戏开发历程</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">所有文章</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2025/02/10/策略游戏地图制作-三-地块LOD/"><span>策略游戏地图制作(三)-地块LOD</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2025/02/10/策略游戏地图制作-三-地块LOD/" rel="bookmark">
        <time class="entry-date published" datetime="2025-02-10T09:55:08.000Z">
          2025-02-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="1-LOD技术概述"><a href="#1-LOD技术概述" class="headerlink" title="1.LOD技术概述"></a>1.LOD技术概述</h1><p>LOD（Level Of Detail）是游戏制作中的重要技术，它的思想很简单，即根据模型在屏幕的占比或直接根据摄像机到模型的距离决定该模型应该采用的精度级别，离的远采用更低精度，以降低渲染成本。</p>
<figure>
    <img src="images/Chapter03/Different_LOD_Models.png" width="700" height="392" alt="image">
    <figcaption>图：不同LOD级别的模型</figcaption>
</figure>

<p>通常来讲我们可以预制不同LOD的Mesh，程序启动时载入内存，然后去做动态切换。像UE可以对导入的模型自动生成不同LOD级别模型，这样做的代价是存储了更多模型Mesh，所以LOD也算一种空间换时间的做法。</p>
<p>LOD不仅仅体现在渲染优化上，它更应该理解为一种思想。LOD在其他领域中也有应用，比如引擎的物理碰撞、动画更新、AI等都可以使用LOD的思想进行优化，许多游戏在做gameplay时也会考虑应用LOD</p>
<h2 id="1-1-LOD-选取"><a href="#1-1-LOD-选取" class="headerlink" title="1.1.LOD 选取"></a>1.1.LOD 选取</h2><p>LOD选取即确定一个模型应该采用的LOD级别，在Unity的LOD Group组件中，提供距离过渡和占屏幕比例的过渡方式，这是比较常用的方法</p>
<figure>
    <img src="images/Chapter03/Unity_LOD_Group.png" width="400" height="350" alt="image">
    <figcaption>图：Unity的LOD Group（虽然它更像是个玩具）</figcaption>
</figure>

<p>一些游戏会采用更复杂的LOD方案，比如采用四叉树，采用四叉树可以达到更精细的划分效果。</p>
<figure>
    <img src="images/Chapter03/QuadTree_Tile.png" width="700" height="392" alt="image">
    <figcaption>图：四叉树中不同层级的地块</figcaption>
</figure>

<p>网上有许多四叉树方案的具体实现，例如：<br><a href = "http://www.cppblog.com/liangairan/articles/48705.html"></a><br><a href = "https://www.cnblogs.com/rainbow70626/p/5268770.html"></a></p>
<h2 id="1-2-LOD-过渡"><a href="#1-2-LOD-过渡" class="headerlink" title="1.2.LOD 过渡"></a>1.2.LOD 过渡</h2><p>LOD过渡是处理不同LOD级别之间的过程，由于不同的LOD级别存在精度差别，会出现裂缝，要修补这类问题，通常有以下的解决方法：</p>
<p>（1）.直接设置顶点位置；很简单粗暴的解决方案，但很多时候却意外地有效，尤其是在修补因Mesh而产生的接缝上，原理图如下。这种修复方式依然会在不同LOD层级之间留下可见的界限</p>
 <figure>
    <img src="images/Chapter03/SetVertPos_FixSeam.png" width="600" height="330" alt="image">
    <figcaption>图：直接设置顶点位置来修补接缝</figcaption>
</figure>


<p>（2）.采用特殊的过渡地带；如用精细的三角型组成条带，但这样做也在每个层级间都留下明显的分界线。</p>
<figure>
    <img src="images/Chapter03/SetTransitPart_FixSeam.png" width="600" height="330" alt="image">
    <figcaption>图：采用特殊的过渡地带修补接缝</figcaption>
</figure>


<p>（3）.无缝过渡；采用一些网格变形算法可以实现不同LOD级别之间的无缝过渡，例如CDLOD，其实现链接：<br><a href = "https://github.com/fstrugar/CDLOD"></a></p>
<figure>
    <img src="images/Chapter03/CDLOD_Img.png" width="600" height="350" alt="image">
    <figcaption>图：CDLOD的演示视频（太糊了）</figcaption>
</figure>


<h2 id="1-3-其他LOD相关技术"><a href="#1-3-其他LOD相关技术" class="headerlink" title="1.3.其他LOD相关技术"></a>1.3.其他LOD相关技术</h2><p>除了上面举例的一些方案外，也有许多被广泛应用的LOD方案，以下举例</p>
<p>（1）.HLOD；HLOD在UE中有内置的支持，它适用于一些3A大世界游戏，基本思想是用一个网格代替多个网格，当距离足够远的时候合并静态网格，可以减少渲染的drawcall，还能节省内存<br>HLOD的介绍：<br><a href = "https://docs.google.com/document/d/1OPYDNpwGFpkBorZ3GCpL9Z4ck-6qRRD1tzelUQ0UvFc/edit?pli=1&tab=t.0#heading=h.kcsddwbeir6p"></a><br>UE的HLOD实现：<br><a href = "https://dev.epicgames.com/documentation/en-us/unreal-engine/hierarchical-level-of-detail-in-unreal-engine?application_version=5.4"></a></p>
<p>（2）.Nanite；其实Nanite也算一个LOD方案，它以一个网格上的Cluster（簇）为单位进行LOD切换，所以切换时玩家不会感觉到明显的突兀。如何划分Cluster、如何修补Cluster之间接缝都是非常有意思的问题。<br>UE官方的视频：<br><a href = "https://www.youtube.com/watch?v=TMorJX3Nj6U&t=7978s"></a><br>感兴趣的也可以看看这个视频对Nanite的解读：<br><a href = "https://www.bilibili.com/video/BV1VV4y157Zb/"></a></p>
<figure>
    <img src="images/Chapter03/Nanite_Img.png" width="700" height="392" alt="image">
    <figcaption>图：Nanite划分簇</figcaption>
</figure>


<h1 id="2-在策略游戏地图中应用LOD"><a href="#2-在策略游戏地图中应用LOD" class="headerlink" title="2.在策略游戏地图中应用LOD"></a>2.在策略游戏地图中应用LOD</h1><p>通常我们在评价地形系统的效果时，都会考虑到渲染性能，渲染性能主要体现在网格顶点的数量上，这是最基本的。除此之外，纹理处理、地表植被处理等也很重要，不过这是后话。</p>
<p>在上一节中，我们为地形做了Cluster-Tile两个层级的划分，这种以Chunk形式组织地图数据的思想在大地图游戏中是非常常用的。以Tile作为LOD的切换单位，采用ChunkLOD的思想去实际应用LOD，具体思路如下：</p>
<p>1.以TerrainTile作为LOD切换的基本单位；<br>2.LOD的切换时机根据摄像机到地块的距离决定，因为是线性的，不会出现跨LOD级别的地块连在一起的情况；<br>3.LOD的过渡地带采用直接设置顶点位置的方式，无他，因为操作简单。采用特殊的过渡地带或者无缝过渡暂不考虑；<br>4.不同LOD的Mesh建议静态生成，程序启动时加载进入内存进行切换（当然如果Mesh数据过大，不想做持久化，也可以动态生成）</p>
<p>有以上思路后，可以确定做LOD的基本步骤：<br>1.为TerrainTile类添加生成不同LOD级别的方法<br>2.增加UpdateTerrain方法，用于动态地根据摄像机距离决定每个Tile应采取的LOD级别<br>3.在Update或者其他Tick方法中调用UpdateTerrain，<br>4.因为LOD级别随时可能改变，LOD接缝处理放到UpdateTerrain中</p>
<h2 id="2-1-构建不同LOD-Mesh"><a href="#2-1-构建不同LOD-Mesh" class="headerlink" title="2.1.构建不同LOD Mesh"></a>2.1.构建不同LOD Mesh</h2><p>在Tile中需要为每个Tile构建不同LOD级别的Mesh，对于每个更低级的LOD级别，顶点数目设置成一半即可，例如我们有4级LOD分级，Tile的尺寸为256，那么LOD0：256顶点每行，LOD1：128每行，LOD2：64每行，LOD3：32每行</p>
<figure>
    <img src="images/Chapter03/Different_LOD_Meshes.png" width="700" height="392" alt="image">
    <figcaption>图：生成不同LOD层级网格</figcaption>
</figure>

<p>在TerrainCluster构建Tile时添加：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] lodLevels = <span class="keyword">new</span> <span class="built_in">int</span>[LODLevel];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; LODLevel; i++) &#123;</span><br><span class="line">    lodLevels[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// generate mesh data for every LOD level</span></span><br><span class="line"><span class="built_in">int</span> curLODLevel = LODLevel - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (curLODLevel &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// when num fix == 1, the vert num per line is equal to tileSize</span></span><br><span class="line">    <span class="built_in">int</span> vertexNumFix = (<span class="built_in">int</span>)Mathf.Pow(<span class="number">2</span>, (LODLevel - curLODLevel - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (vertexNumFix &gt; tileSize) &#123;</span><br><span class="line">        <span class="comment">// wrong</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tileNumPerLine; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; tileNumPerLine; j++) &#123;</span><br><span class="line">            terrainTileList[i, j].SetMeshData(curLODLevel, tileSize, vertexNumFix, terrainClusterSize, heightDataManager);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    curLODLevel--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在TerrainTile构建Mesh时添加如下代码。原理很简单，每次生成较低精度的LOD级别时，省略一半的顶点，</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetMeshData</span>(<span class="params"><span class="built_in">int</span> curLODLevel, <span class="built_in">int</span> tileSize, <span class="built_in">int</span> vertexNumFix, Vector3Int terrainClusterSize, HeightDataManager heightDataManager</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.tileSize = tileSize;</span><br><span class="line">    <span class="keyword">this</span>.heightDataManager = heightDataManager;</span><br><span class="line">    <span class="comment">// caculate tile&#x27;s start point</span></span><br><span class="line">    <span class="built_in">float</span> startX = tileIdxX * tileSize;</span><br><span class="line">    <span class="built_in">float</span> startZ = tileIdxY * tileSize;</span><br><span class="line">    Vector3 startPoint = <span class="keyword">new</span> Vector3(startX, <span class="number">0</span>, startZ) + <span class="keyword">this</span>.clusterStartPoint;       <span class="comment">// </span></span><br><span class="line">    tileCenterPos = startPoint + <span class="keyword">new</span> Vector3(tileSize / <span class="number">2</span>, <span class="number">0</span>, tileSize / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">int</span> gridNumPerLine = tileSize / vertexNumFix;</span><br><span class="line">    <span class="built_in">int</span> gridSize = tileSize / gridNumPerLine;</span><br><span class="line">    <span class="built_in">int</span> vertexPerLine = tileSize / vertexNumFix + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> gridNumPerLineFixed = gridNumPerLine + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int</span> vertexPerLineFixed = vertexPerLine + <span class="number">2</span>;</span><br><span class="line">    LODMeshes[curLODLevel] = <span class="keyword">new</span> MeshData();</span><br><span class="line">    MeshData meshData = LODMeshes[curLODLevel];</span><br><span class="line">    meshData.InitMeshData(gridNumPerLine, gridNumPerLineFixed, vertexPerLine, vertexPerLineFixed);</span><br><span class="line">    <span class="built_in">int</span> curInVertIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> curOutVertIdx = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//int[,] vertexIndiceMap = new int[vertexPerLineFixed, vertexPerLineFixed];</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> use job system</span></span><br><span class="line">    Vector3 offsetInMeshVert = <span class="keyword">new</span> Vector3(gridSize, <span class="number">0</span>, gridSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; vertexPerLineFixed; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; vertexPerLineFixed; j++) &#123;</span><br><span class="line">            <span class="built_in">bool</span> isVertOutOfMesh = (i == <span class="number">0</span>) || (i == vertexPerLineFixed - <span class="number">1</span>) || (j == <span class="number">0</span>) || (j == vertexPerLineFixed - <span class="number">1</span>);</span><br><span class="line">            Vector3 vert = <span class="keyword">new</span> Vector3(gridSize * i, <span class="number">0</span>, gridSize * j) + startPoint - offsetInMeshVert;</span><br><span class="line">            <span class="comment">//float height = SampleFromHeightData(terrainClusterSize, vert);</span></span><br><span class="line">            <span class="built_in">float</span> height = heightDataManager.SampleFromHeightData(longitude, latitude, vert, clusterStartPoint);</span><br><span class="line">            <span class="comment">//float height = 0;</span></span><br><span class="line">            vert.y = height;</span><br><span class="line">            Vector2 uv = <span class="keyword">new</span> Vector2(vert.x / terrainClusterSize.x, vert.z / terrainClusterSize.z);</span><br><span class="line">            <span class="keyword">if</span> (isVertOutOfMesh) &#123;</span><br><span class="line">                meshData.AddVertex(vert, uv, curOutVertIdx);</span><br><span class="line">                meshData.SetIndiceInMap(i, j, curOutVertIdx);</span><br><span class="line">                <span class="comment">//vertexIndiceMap[i, j] = curOutVertIdx;</span></span><br><span class="line">                curOutVertIdx --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                meshData.AddVertex(vert, uv, curInVertIdx);</span><br><span class="line">                meshData.SetIndiceInMap(i, j, curInVertIdx);</span><br><span class="line">                <span class="comment">//vertexIndiceMap[i, j] = curInVertIdx;</span></span><br><span class="line">                curInVertIdx ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> curGridIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; gridNumPerLineFixed; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; gridNumPerLineFixed; j++) &#123;</span><br><span class="line">            <span class="comment">// i, j 是当前遍历到的 grid 的 index</span></span><br><span class="line">            <span class="built_in">int</span> cur_w = curGridIdx % gridNumPerLineFixed;</span><br><span class="line">            <span class="built_in">int</span> cur_h = curGridIdx / gridNumPerLineFixed;</span><br><span class="line">            <span class="built_in">int</span> next_w = cur_w + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> next_h = cur_h + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> a = meshData.GetIndiceInMap(cur_w, cur_h);</span><br><span class="line">            <span class="built_in">int</span> b = meshData.GetIndiceInMap(cur_w, next_h);</span><br><span class="line">            <span class="built_in">int</span> c = meshData.GetIndiceInMap(next_w, next_h);</span><br><span class="line">            <span class="built_in">int</span> d = meshData.GetIndiceInMap(next_w, cur_h);</span><br><span class="line">            meshData.AddTriangle(a, b, c, i, j);</span><br><span class="line">            meshData.AddTriangle(a, c, d, i, j);</span><br><span class="line">            curGridIdx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    meshData.RecaculateNormal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-UpdateTerrain"><a href="#2-2-UpdateTerrain" class="headerlink" title="2.2.UpdateTerrain"></a>2.2.UpdateTerrain</h2><p>UpdateTerrain处主要是为了在程序运行时做LOD的更新，以下是关键代码。下方代码中的一些部分留到后面讲解，并到后面修接缝时给出一些方法的代码。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateTerrain</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// NOTE : 当前直接使用主摄像机位置判断是否要加载此块</span></span><br><span class="line">    Vector3 cameraPos = Camera.main.transform.position;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> cluster <span class="keyword">in</span> clusterList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cluster.IsValid) &#123;</span><br><span class="line">            <span class="built_in">int</span> x = cluster.idxX;</span><br><span class="line">            <span class="built_in">int</span> y = cluster.idxY;</span><br><span class="line">            <span class="built_in">int</span> leftIdx = x - <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> rightIdx = x + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> upIdx = y + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> downIdx = y - <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span>[,] direction = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>, <span class="number">2</span>]&#123;</span><br><span class="line">                &#123;leftIdx, y&#125;,&#123;rightIdx, y&#125;, &#123;x, upIdx&#125;, &#123;x, downIdx&#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//  find neighbours, the sequence is : left, right, up, down;</span></span><br><span class="line">            List&lt;TerrainCluster&gt; terrainClusters = <span class="keyword">new</span> List&lt;TerrainCluster&gt;(<span class="number">4</span>) &#123; <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">int</span> neighborX = direction[i, <span class="number">0</span>];</span><br><span class="line">                <span class="built_in">int</span> neighborY = direction[i, <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (clusterList.IsValidIndex(neighborX, neighborY) &amp;&amp; clusterList[neighborX, neighborY].IsValid) &#123;</span><br><span class="line">                    terrainClusters[i] = clusterList[neighborX, neighborY];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TDList&lt;<span class="built_in">int</span>&gt; fullLodLevelMap = clusterList[x, y].GetFullLODLevelMap(cameraPos, </span><br><span class="line">                terrainClusters[<span class="number">0</span>], terrainClusters[<span class="number">1</span>], terrainClusters[<span class="number">2</span>], terrainClusters[<span class="number">3</span>]);</span><br><span class="line">            cluster.UpdateTerrainCluster(fullLodLevelMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(<span class="built_in">string</span>.Format(<span class="string">&quot;update terrain cluster num &#123;0&#125;&quot;</span>, clusterList.GetLength(<span class="number">0</span>) * clusterList.GetLength(<span class="number">0</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新时机可以自己确定，建议用摄像机移动事件触发更新，每当摄像机移动到不同地块时触发更新，以降低检测代价。这里的UpdateTerrain直接放到了编辑器用按钮来执行，运行时的机制暂时未写，放到后面做。</p>
<h2 id="2-3-获得全局LODMap"><a href="#2-3-获得全局LODMap" class="headerlink" title="2.3.获得全局LODMap"></a>2.3.获得全局LODMap</h2><p>之前提到过，要在UpdateTerrain中去处理LOD接缝，因为每个地块的LOD接缝都是动态改变的，我们需要实时地知道每个Tile当前的LOD级别，所以需要在确定LOD后，再进行接缝修补。为此我们只需要一个二维数组，记录每个Index下的Tile的LOD即可完成</p>
<p>同样地因为在TerrainCluster中我们只知道这个Cluster下属的Tile的LOD级别，而不知道其他cluster下的Tile的LOD，这就会导致不同Cluster衔接的Tile之间出现接缝，如下图所示：</p>
<figure>
    <img src="images/Chapter03/Seam_BetweenClusters.png" width="700" height="392" alt="image">
    <figcaption>图：不同Cluster之间的接缝(图右)</figcaption>
</figure>


<p>为此我们需要获得全局的LODMap然后传入到Cluster中进行更新。在上方的代码中，我们获取了fullLodLevelMap，即： </p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TDList&lt;<span class="built_in">int</span>&gt; fullLodLevelMap = clusterList[x, y].GetFullLODLevelMap(cameraPos, terrainClusters[<span class="number">0</span>],  terrainClusters[<span class="number">1</span>],  terrainClusters[<span class="number">2</span>],  terrainClusters[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<p>这个方法会返回本Cluster下的所有Tile的LOD级别，并会多包含Cluster相邻的其他Cluster下的Tile的LOD级别。具体逻辑很简单，获取到相邻的四个TerrainCluster即可，代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">internal</span> TDList&lt;<span class="built_in">int</span>&gt; <span class="title">GetFullLODLevelMap</span>(<span class="params">Vector3 cameraPos, TerrainCluster left, TerrainCluster right, TerrainCluster up, TerrainCluster down</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> tileWidth = terrainTileList.GetLength(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">int</span> tileHeight = terrainTileList.GetLength(<span class="number">0</span>);</span><br><span class="line">    TDList&lt;<span class="built_in">int</span>&gt; lodLevelMap = GetLODLevelMap(cameraPos);</span><br><span class="line">    TDList&lt;<span class="built_in">int</span>&gt; fullLodLevelMap = <span class="keyword">new</span> TDList&lt;<span class="built_in">int</span>&gt;(tileWidth + <span class="number">2</span>, tileHeight + <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// copy cluster&#x27;s lodlevelmap to fulllodlevelmap</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; tileWidth + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>; j &lt; tileHeight + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            fullLodLevelMap[i, j] = lodLevelMap[i - <span class="number">1</span>, j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy egde&#x27;s lodlevelmap to fulllodlevelmap. careful for the sequence</span></span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; leftLODLevel = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftLODLevel = left.GetEdgeLODLevel(cameraPos, GetEdgeDir.Right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tileHeight; i ++) &#123;</span><br><span class="line">        fullLodLevelMap[<span class="number">0</span>, i + <span class="number">1</span>] = leftLODLevel[i];</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; rightLODLevel = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">        rightLODLevel = right.GetEdgeLODLevel(cameraPos, GetEdgeDir.Left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tileHeight; i++) &#123;</span><br><span class="line">        fullLodLevelMap[tileHeight + <span class="number">1</span>, i + <span class="number">1</span>] = rightLODLevel[i];</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; upLODLevel = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (up != <span class="literal">null</span>) &#123;</span><br><span class="line">        upLODLevel = up.GetEdgeLODLevel(cameraPos, GetEdgeDir.Down);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tileWidth; i++) &#123;</span><br><span class="line">        fullLodLevelMap[i + <span class="number">1</span>, tileWidth + <span class="number">1</span>] = upLODLevel[i];</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; downLODLevel = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (down != <span class="literal">null</span>) &#123;</span><br><span class="line">        downLODLevel = down.GetEdgeLODLevel(cameraPos, GetEdgeDir.Up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tileWidth; i++) &#123;</span><br><span class="line">        fullLodLevelMap[i + <span class="number">1</span>, <span class="number">0</span>] = downLODLevel[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullLodLevelMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-4-处理LOD接缝"><a href="#2-4-处理LOD接缝" class="headerlink" title="2.4.处理LOD接缝"></a>2.4.处理LOD接缝</h2><p>在上面的UpdateTerrain方法中，为了减轻代码量，将部分的更新逻辑放到了Cluster中做，即下方所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster.UpdateTerrainCluster(fullLodLevelMap);</span><br></pre></td></tr></table></figure>

<p>该方法的逻辑处理中，会多一步判断相邻的Tile的LOD级别是否不同，如果不同就表示要修复对应的边，完整代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateTerrainCluster</span>(<span class="params">TDList&lt;<span class="built_in">int</span>&gt; fullLodLevelMap</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> tileMeshData <span class="keyword">in</span> terrainTileList) &#123;</span><br><span class="line">        <span class="comment">// use full lod map, so index offset is 1</span></span><br><span class="line">        <span class="built_in">int</span> x = tileMeshData.tileIdxX + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> y = tileMeshData.tileIdxY + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> lodLevel = fullLodLevelMap[x, y];</span><br><span class="line">        <span class="built_in">int</span> left = x - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> right = x + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> top = y + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> bottom = y - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// check if should fix LOD seam</span></span><br><span class="line">        <span class="built_in">int</span> fixSeamDirection = <span class="number">10000</span>;</span><br><span class="line">        <span class="built_in">int</span>[,] direction = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>, <span class="number">2</span>]&#123;</span><br><span class="line">            &#123;left, y&#125;,&#123;right, y&#125;, &#123;x, top&#125;, &#123;x, bottom&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> idxX = direction[i, <span class="number">0</span>];</span><br><span class="line">            <span class="built_in">int</span> idxY = direction[i, <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (fullLodLevelMap.IsValidIndex(idxX, idxY) &amp;&amp; lodLevel &gt; fullLodLevelMap[idxX, idxY]) &#123;</span><br><span class="line">                fixSeamDirection |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不管LOD层级有没有发生改变，都必须重新刷新mesh，因为要处理LOD接缝</span></span><br><span class="line">        Mesh mesh = tileMeshData.GetMesh(lodLevel, fixSeamDirection);</span><br><span class="line">        tileMeshData.SetMesh(mesh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Debug.Log(string.Format(&quot;update successfully! handle tile num &#123;0&#125;&quot;, terrainTileList.GetLength(0)));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Tile的MeshData类中，传入具体的LOD级别和需要修复的边即可完成接缝修复。对于要修复的边，如果相邻的Tile的LOD级别更大（更没那么精细），我们只需要将它的多余的顶点设置为相邻顶点的高度即可，原理图如下所示：</p>
<figure>
    <img src="images/Chapter03/Condition_FixSeam.png" width="300" height="300" alt="image">
    <figcaption>图：如果相邻Tile的LOD不同则需要修复</figcaption>
</figure>

<p>完整代码如下（注：下方的RecaculateBorderNormal作用和RecaculateNormal一样，但仅计算边缘顶点的法线，因为没必要再重新计算Tile内部的顶点法线了）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Mesh <span class="title">GetMesh</span>(<span class="params"><span class="built_in">int</span> tileIdxX, <span class="built_in">int</span> tileIdxY, <span class="built_in">int</span> fixDirection</span>)</span> &#123;</span><br><span class="line">    Mesh mesh = <span class="keyword">new</span> Mesh();</span><br><span class="line">    mesh.name = <span class="built_in">string</span>.Format(<span class="string">&quot;TerrainMesh_LOD&#123;0&#125;_Idx&#123;1&#125;_&#123;2&#125;&quot;</span>, curLODLevel, tileIdxX, tileIdxY);</span><br><span class="line">    <span class="comment">// fix the lod seam</span></span><br><span class="line">    fixedVertexs = vertexs;</span><br><span class="line">    fixedOutMeshVertexs = outofMeshVertexs;</span><br><span class="line">    <span class="built_in">bool</span> fixLeft = ((fixDirection &gt;&gt; <span class="number">0</span>) &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bool</span> fixRight = ((fixDirection &gt;&gt; <span class="number">1</span>) &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bool</span> fixTop = ((fixDirection &gt;&gt; <span class="number">2</span>) &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bool</span> fixBottom = ((fixDirection &gt;&gt; <span class="number">3</span>) &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (fixLeft) &#123;</span><br><span class="line">        <span class="comment">// NOTE : 这块代码和外层 TileMeshData.SetMeshData 存在耦合，很重的耦合</span></span><br><span class="line">        FixLODEdgeSeam(<span class="literal">true</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fixRight) &#123;</span><br><span class="line">        FixLODEdgeSeam(<span class="literal">true</span>, vertexPerLineFixed - <span class="number">1</span>, vertexPerLineFixed - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fixTop) &#123;</span><br><span class="line">        FixLODEdgeSeam(<span class="literal">false</span>, vertexPerLineFixed - <span class="number">1</span>, vertexPerLineFixed - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fixBottom) &#123;</span><br><span class="line">        FixLODEdgeSeam(<span class="literal">false</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//RecaculateNormal();</span></span><br><span class="line">    RecaculateBorderNormal();</span><br><span class="line">    mesh.vertices = fixedVertexs;</span><br><span class="line">    mesh.normals = normals;</span><br><span class="line">    mesh.triangles = triangles;</span><br><span class="line">    mesh.uv = uvs;</span><br><span class="line">    mesh.colors = colors;</span><br><span class="line">    <span class="keyword">return</span> mesh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对每个需要修复的边缘，封装如下方法进行操作，该方法会根据传入的参数判断对哪条边进行修复：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixLODEdgeSeam</span>(<span class="params"><span class="built_in">bool</span> isVertical, <span class="built_in">int</span> outIdx, <span class="built_in">int</span> inIdx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt; vertexPerLine + <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// traverse the indice map and reset the vertex position to neighbor&#x27;s average</span></span><br><span class="line">        <span class="built_in">int</span> outNgb1Idx, outNgb2Idx, outofMeshIdx;</span><br><span class="line">        <span class="built_in">int</span> inNgb1Idx, inNgb2Idx, inMeshIdx;</span><br><span class="line">        <span class="comment">//Vector3 pointA = (indexA &lt; 0) ? outofMeshVertexs[-indexA - 1] : vertexs[indexA];</span></span><br><span class="line">        <span class="keyword">if</span> (isVertical) &#123;</span><br><span class="line">            outNgb1Idx = vertexIndiceMap[outIdx, i - <span class="number">1</span>];</span><br><span class="line">            outNgb2Idx = vertexIndiceMap[outIdx, i + <span class="number">1</span>];</span><br><span class="line">            outofMeshIdx = vertexIndiceMap[outIdx, i];</span><br><span class="line">            inNgb1Idx = vertexIndiceMap[inIdx, i - <span class="number">1</span>];</span><br><span class="line">            inNgb2Idx = vertexIndiceMap[inIdx, i + <span class="number">1</span>];</span><br><span class="line">            inMeshIdx = vertexIndiceMap[inIdx, i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outNgb1Idx = vertexIndiceMap[i - <span class="number">1</span>, outIdx];</span><br><span class="line">            outNgb2Idx = vertexIndiceMap[i + <span class="number">1</span>, outIdx];</span><br><span class="line">            outofMeshIdx = vertexIndiceMap[i, outIdx];</span><br><span class="line"></span><br><span class="line">            inNgb1Idx = vertexIndiceMap[i - <span class="number">1</span>, inIdx];</span><br><span class="line">            inNgb2Idx = vertexIndiceMap[i + <span class="number">1</span>, inIdx];</span><br><span class="line">            inMeshIdx = vertexIndiceMap[i, inIdx];</span><br><span class="line">        &#125;</span><br><span class="line">        fixedOutMeshVertexs[-outofMeshIdx - <span class="number">1</span>] = (fixedOutMeshVertexs[-outNgb1Idx - <span class="number">1</span>] + fixedOutMeshVertexs[-outNgb2Idx - <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">        fixedVertexs[inMeshIdx] = (fixedVertexs[inNgb1Idx] + fixedVertexs[inNgb2Idx]) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行UpdateTerrain后，最终结果，无缝地形：</p>
<figure>
    <img src="images/Chapter03/Fixed01.png" width="700" height="392" alt="image">
    <img src="images/Chapter03/Fixed02.png" width="700" height="392" alt="image">
    <figcaption>图：修补接缝后的地形</figcaption>
</figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/12/31/策略游戏地图制作-二-Terrain生成-下/"><span>策略游戏地图制作(二)_Terrain生成_下</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/12/31/策略游戏地图制作-二-Terrain生成-下/" rel="bookmark">
        <time class="entry-date published" datetime="2024-12-30T16:00:00.000Z">
          2024-12-31
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="1-高度图处理"><a href="#1-高度图处理" class="headerlink" title="1.高度图处理"></a>1.高度图处理</h1><h2 id="1-1-高度图获取"><a href="#1-1-高度图获取" class="headerlink" title="1.1.高度图获取"></a>1.1.高度图获取</h2><p>高度图本质上是一个二维数组，或者一个灰度图，存储指定xy坐标下的高度信息。运行时对高度数据采样来得知一个vert应该应用的高度，从而生成地形。可以通过一些算法生成高度图（如噪声），但为还原真实地形地貌，此处直接使用真实地理高度图，后续添加对地图的编辑功能来做微调</p>
<p>首先，要获取到真实地图的高度图数据。可以从一些开源的地理信息网站得到，此处以 USGS为例，网址为：<br><a href = "https://earthexplorer.usgs.gov/"></a></p>
<p>打开网页后，在地图上点选以选取范围，转到DataSets下选择要下载的对应项</p>
<figure>
    <img src="images/Chapter02/Download_UGUS01.png" width="700" height="392" alt="image">
    <figcaption>图：USGS界面</figcaption>
</figure>

<p>点击result或直接转到results页面即获取到对应的地块信息，可以选择TIF、DEM格式，这里使用TIF，下载后得到灰度图</p>
<figure>
    <img src="images/Chapter02/Download_UGUS02.png" width="700" height="392" alt="image">
    <figcaption>图：USGS界面</figcaption>
</figure>

<p>下载得到的高度图内容，分辨率3601x3601，大小30MB左右：</p>
<figure>
    <img src="images/Chapter02/Download_UGUS03.png" width="700" height="392" alt="image">
    <figcaption>图：下载得到的高度图内容</figcaption>
</figure>


<h2 id="1-2-高度图的序列化"><a href="#1-2-高度图的序列化" class="headerlink" title="1.2.高度图的序列化"></a>1.2.高度图的序列化</h2><p>得到高度图资源后，就可以考虑先对高度图进行预处理了。简要说一下处理高度图数据的思路：</p>
<p>-首先，3601x3601的数据规模太大了，我们构建地图时完全不需要这么大的数据量，所以需要对原数据进行压缩处理，压缩为指定分辨率的数据<br>-其次，压缩后得到的高度信息可以序列化到一个指定格式的二进制文件，在Runtime时加载这个二进制文件，解析后再应用到Terrain上生成地形（之后会测试地图流式加载的性能，再思考优化）</p>
<p>思路已有，那么就可以开始了</p>
<p>先进行高度图压缩，采用简单的双线性插值，原理如图。最终返回目的分辨率尺寸的高度数据：（其实在这里可以做进一步的压缩工作，如果我们追求的地图精度不需要太高，完全可以换成单通道-8bit纹理来存储数据，后续如优化有需要再做改动）</p>
<figure>
    <img src="images/Chapter02/Bilinear.png" width="400" height="400" alt="image">
    <figcaption>图：双线性插值的原理</figcaption>
</figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">float</span>[,] CompressHeightData(<span class="built_in">string</span> heightMapPath) &#123;</span><br><span class="line">    <span class="built_in">float</span>[,] heights = ReadHeightMapData(heightMapPath);</span><br><span class="line">    <span class="built_in">float</span>[,] compressedHeights = <span class="keyword">new</span> <span class="built_in">float</span>[compressResultSize, compressResultSize];</span><br><span class="line">    <span class="built_in">int</span> srcWsidth = heights.GetLength(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">int</span> dstHeight = heights.GetLength(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// resample the size of height map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; compressResultSize; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; compressResultSize; j++) &#123;</span><br><span class="line">            <span class="built_in">float</span> sx = i * (<span class="built_in">float</span>)(srcWsidth - <span class="number">1</span>) / compressResultSize;</span><br><span class="line">            <span class="built_in">float</span> sy = j * (<span class="built_in">float</span>)(dstHeight - <span class="number">1</span>) / compressResultSize;</span><br><span class="line">            <span class="built_in">int</span> x0 = Mathf.FloorToInt(sx);</span><br><span class="line">            <span class="built_in">int</span> x1 = Mathf.Min(x0 + <span class="number">1</span>, srcWsidth - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">int</span> y0 = Mathf.FloorToInt(sy);</span><br><span class="line">            <span class="built_in">int</span> y1 = Mathf.Min(y0 + <span class="number">1</span>, dstHeight - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">float</span> q00 = heights[x0, y0];</span><br><span class="line">            <span class="built_in">float</span> q01 = heights[x0, y1];</span><br><span class="line">            <span class="built_in">float</span> q10 = heights[x1, y0];</span><br><span class="line">            <span class="built_in">float</span> q11 = heights[x1, y1];</span><br><span class="line">            <span class="built_in">float</span> rx0 = Mathf.Lerp(q00, q10, sx - x0);</span><br><span class="line">            <span class="built_in">float</span> rx1 = Mathf.Lerp(q01, q11, sx - x0);</span><br><span class="line">            <span class="comment">// caculate the height by the data given</span></span><br><span class="line">            <span class="built_in">float</span> h = Mathf.Lerp(rx0, rx1, sy - y0);</span><br><span class="line">            <span class="built_in">float</span> fixed_h = Mathf.Clamp(h, <span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">            compressedHeights[i, j] = fixed_h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> compressedHeights;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到指定的高度图文件的加载路径，读取所有TIF文件，然后写入数据到序列化文件中，以下是关键部分的代码（考虑到代码量，其他部分代码&#x2F;参数未放到下方，请读者自行添加）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(outputFile, FileMode.CreateNew, FileAccess.Write)) &#123;</span><br><span class="line">    <span class="keyword">using</span> (BinaryWriter writer = <span class="keyword">new</span> BinaryWriter(fs)) &#123;</span><br><span class="line">        <span class="comment">// file header : fileNum, single fileSize  // Int32</span></span><br><span class="line">        writer.Write(inputFilePaths.Length);</span><br><span class="line">        writer.Write(size);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> inputFilePath <span class="keyword">in</span> inputFilePaths) &#123;</span><br><span class="line">            <span class="built_in">string</span> fixedFilePath = AssetsUtility.GetInstance().FixFilePath(inputFilePath);</span><br><span class="line">            <span class="comment">// get tif file info from the name, such as &quot;n33_e110_1arc_v3&quot;</span></span><br><span class="line">            <span class="built_in">string</span> inputFileName = Path.GetFileName(fixedFilePath);</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// get height data and write to file</span></span><br><span class="line">            <span class="built_in">float</span>[,] heightMap = CompressHeightData(fixedFilePath);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                    writer.Write(heightMap[i, j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从USGS下载的TIF文件都遵循着：n{纬度}_e{经度}的命名格式。我们在序列化文件数据时，也按照这个格式读取TIF文件的经纬度信息写入文件当中，后续用作识别地块信息。以下是关键代码部分：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] heightMapPaths = Directory.GetFiles(heightMapInputPath, <span class="string">&quot;*.tif&quot;</span>, SearchOption.AllDirectories);</span><br><span class="line"><span class="built_in">string</span> inputFileName = Path.GetFileName(fixedFilePath);</span><br><span class="line"><span class="comment">// read the tif file, get longitude and latitude, write to this output file</span></span><br><span class="line">Match matchLatitude = Regex.Match(tifFileInfo[<span class="number">0</span>], <span class="string">@&quot;^[a-zA-Z]+(\d+)$&quot;</span>);</span><br><span class="line"><span class="built_in">int</span> latitude = <span class="built_in">int</span>.Parse(matchLatitude.Groups[<span class="number">1</span>].Value);</span><br><span class="line">Match matchLongitude = Regex.Match(tifFileInfo[<span class="number">1</span>], <span class="string">@&quot;^[a-zA-Z]+(\d+)$&quot;</span>);</span><br><span class="line"><span class="built_in">int</span> longitude = <span class="built_in">int</span>.Parse(matchLongitude.Groups[<span class="number">1</span>].Value);</span><br><span class="line">writer.Write(latitude);</span><br><span class="line">writer.Write(longitude);</span><br></pre></td></tr></table></figure>

<p>最终执行上面的方法，你可以自己定义编辑器窗口使用序列化功能。也可以在Odin编辑器中写一个对应的处理窗口，这里结合之前的编辑器搭建工作，写了个高度图编辑器，界面如下（由于Odin布局代码并不好看，此处不放上编辑器类的源码）：</p>
<figure>
    <img src="images/Chapter02/HeightEditor.png" width="700" height="392" alt="image">
    <figcaption>图：高度图编辑器</figcaption>
</figure>
 

<p>点击上方的序列化高度图，在导出位置生成了序列化后的高度图文件：<br>（注：Odin部分的代码并不好看，此处仍然不放上，读者可自行通过Odin的API添加上导出与导入按钮的逻辑，上述的编辑器面板也仅是为了方便测试，重点在于序列化的逻辑）</p>
 <figure>
    <img src="images/Chapter02/HeightData_Serialized.png" width="700" height="320" alt="image">
    <img src="images/Chapter02/HeightData_Serialized02.png" width="700" height="50" alt="image">
    <figcaption>图：序列化后的高度图文件</figcaption>
</figure>
 

<p>由于在序列化过程中进行了数据压缩，同时序列化后的文件剔除了TIF文件的多余信息，所以序列化后文件大小显著降低，从原来的十几个25MB的TIF文件压缩为一个23MB的文件，更适合用于存储高度数据。后续可以根据实际游戏开发需要，选取合适的分辨率进行生成</p>
<h2 id="1-3-高度图的反序列化"><a href="#1-3-高度图的反序列化" class="headerlink" title="1.3.高度图的反序列化"></a>1.3.高度图的反序列化</h2><p>上面的过程完成了高度图数据的预处理，现在我们已经可以在磁盘中读取到高度图文件。但高度信息最终还是需要加载进入内存，才能在Runtime中用于构建地形。</p>
<p>本节实现高度数据的反序列化</p>
<p>首先，为方便Runtime下的高度数据表示，我们需要先建立数据类用于存储高度图信息，该类中需要有的关键字段有：<br>-该高度数据对应的TIF文件（之前提到过从UGUS下载的文件都遵循n{纬度}_e{经度}的命名格式，所以记录 经纬度 数据即可）<br>-高度数据，float的列表（如对性能有要求，可压缩数据精度，改用更小的类型）<br>-高度数据大小，即size</p>
<p>以下是该数据类的字段部分代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HeightData</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> longitude;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> latitude;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> size;</span><br><span class="line">    [<span class="meta">SerializeField</span>] List&lt;<span class="built_in">float</span>&gt; heightDatas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，因为一个序列化后的文件对应多个TIF文件，也就是对应多个现实地理的地块，上面的一个HeightData仅对应一个地块，所以我们还需要在外层再添加一层数据组织类，用于管理HeightData，该类需要有以下字段：<br>-该数据类存储了多少个TIF文件数据<br>-单个TIF文件数据的大小<br>-HeightData的列表（因为该类用于管理HeightData）</p>
<p>以下是该类的字段部分代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HeightDataModel</span> : <span class="title">ScriptableObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> heightFileNums;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> singleHeightFileSize;</span><br><span class="line">[<span class="meta">SerializeField</span>] List&lt;HeightData&gt; heightDataList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeightDataModel继承了SO是为了直接存储在磁盘里，更方便在Unity Editor中使用，后续也可以在Runtime中加载这个SO。当然也可以直接加载之前的序列化文件获取高度数据，<br>不过在Editor下更麻烦些。最终我们建立起来的数据对应关系是一个HeightDataModel包含多个HeightData。<br>建立完Runtime下的高度数据模型后，开始写反序列化逻辑，关键代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(fileRelativePath, FileMode.Open, FileAccess.Read)) &#123;</span><br><span class="line">    <span class="keyword">using</span> (BinaryReader reader = <span class="keyword">new</span> BinaryReader(fs)) &#123;</span><br><span class="line">        <span class="built_in">int</span> fileNum = reader.ReadInt32();</span><br><span class="line">        <span class="built_in">int</span> singleFileWidth = reader.ReadInt32();</span><br><span class="line">        Debug.Log(<span class="string">$&quot;header info, num of files : <span class="subst">&#123;fileNum&#125;</span>, single file size : <span class="subst">&#123;singleFileWidth&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HeightDataModel heightDataModel = ScriptableObject.CreateInstance&lt;HeightDataModel&gt;();</span><br><span class="line">        heightDataModel.InitHeightModel(fileNum, singleFileWidth);</span><br><span class="line">        DateTime dateTime = DateTime.Now;</span><br><span class="line">        <span class="built_in">string</span> modelName = <span class="built_in">string</span>.Format(<span class="string">&quot;HeightModel_&#123;0&#125;files_&#123;1&#125;.asset&quot;</span>, fileNum, dateTime.Ticks);</span><br><span class="line">        heightDataModel.name = modelName;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; fileNum; i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> latitude = reader.ReadInt32();</span><br><span class="line">            <span class="built_in">int</span> longitude = reader.ReadInt32();</span><br><span class="line">            <span class="built_in">float</span>[,] heightDatas = <span class="keyword">new</span> <span class="built_in">float</span>[singleFileWidth, singleFileWidth];</span><br><span class="line">            <span class="comment">// read the height data then add to the heightDataModel</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> q = <span class="number">0</span>; q &lt; singleFileWidth; q++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> p  = <span class="number">0</span>; p &lt; singleFileWidth;  p++) &#123;</span><br><span class="line">                    heightDatas[q, p] = reader.ReadSingle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;now add a height data n<span class="subst">&#123;latitude&#125;</span>, e<span class="subst">&#123;longitude&#125;</span>, file width <span class="subst">&#123;singleFileWidth&#125;</span>&quot;</span>);</span><br><span class="line">            heightDataModel.AddHeightData(longitude, latitude, singleFileWidth, heightDatas);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> assetFullPath = AssetsUtility.GetInstance().GetCombinedPath(deserlOutputFilePath, modelName);</span><br><span class="line">        AssetDatabase.CreateAsset(heightDataModel, assetFullPath);</span><br><span class="line">        AssetDatabase.SaveAssets();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了填补上述代码的部分方法空缺，还需要在HeightDataModel与HeightData中添加如下代码逻辑：</p>
<p>在HeightDataModel中，添加初始化方法和加入HeightData类的方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitHeightModel</span>(<span class="params"><span class="built_in">int</span> heightFileNums, <span class="built_in">int</span> size</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.heightFileNums = heightFileNums;</span><br><span class="line">    <span class="keyword">this</span>.singleHeightFileSize = size;</span><br><span class="line">    heightDataList = <span class="keyword">new</span> List&lt;HeightData&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddHeightData</span>(<span class="params"><span class="built_in">int</span> longitude, <span class="built_in">int</span> latitude, <span class="built_in">int</span> size, <span class="built_in">float</span>[,] heightDatas</span>)</span> &#123;</span><br><span class="line">    HeightData heightData = <span class="keyword">new</span> HeightData(longitude, latitude, size, heightDatas);</span><br><span class="line">    heightDataList.Add(heightData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeightData中，传入float[]高度数据用于初始化，添加一个写入高度数据的方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeightData</span>(<span class="params"><span class="built_in">int</span> longitude, <span class="built_in">int</span> latitude, <span class="built_in">int</span> size, <span class="built_in">float</span>[,] heightDatas</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.longitude = longitude;</span><br><span class="line">    <span class="keyword">this</span>.latitude = latitude;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">this</span>.heightDatas = <span class="keyword">new</span> List&lt;<span class="built_in">float</span>&gt;(size * size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            SetHeight(i, j, heightDatas[i, j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetHeight</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">int</span> j, <span class="built_in">float</span> height</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= size || j &lt; <span class="number">0</span> || j &gt;= size) &#123;</span><br><span class="line">        Debug.LogError(<span class="string">$&quot;out of index, error index <span class="subst">&#123;i&#125;</span>, <span class="subst">&#123;j&#125;</span>, size is <span class="subst">&#123;size&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> idx = i * size + j;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= heightDatas.Count) &#123;</span><br><span class="line">        <span class="keyword">this</span>.heightDatas.Add(height);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.heightDatas[idx] = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这里的HeightDataModel继承了ScriptableObject，同时持久化成为了Unity资产，所以在执行了反序列化逻辑后可以在文件浏览器中看到生成的HeightDataModel实例：</p>
<p>自此我们已经建立起高度数据的组织形式，后面我们可以添加逻辑，将高度数据应用到地形实践上</p>
<h1 id="2-应用高度图到地块"><a href="#2-应用高度图到地块" class="headerlink" title="2.应用高度图到地块"></a>2.应用高度图到地块</h1><p>我们的Terrain地图依然是一片平地，现在需要将已经组织好的高度图应用到Terrain上。但目前却有以下的问题：<br>-首先，Terrain地块的尺寸和高度图尺寸不一定一致，考虑到后续要做不同LOD的Terrain地块，基本不可能一一对应，应该如何为每个vertex采样高度？<br>-其次，TerrainCluster对应不同的TIF文件，怎么让不同的TIF文件对应到每个地块，并且保证它们连续？</p>
<p>对于第一个问题，我们可以直接映射，获取到高度图尺寸与地形尺寸后，根据其宽高找到地形上的顶点在高度图上对应的数据</p>
<p>对于第二个问题，先前提到，因为我们使用真实地理数据，所以TerrainCluster对应的TIF高度图文件都是有经纬度标注的，这也许可以作为构建每个Cluster的次序的信息。如果你使用其他途径得到的高度图数据，可以手动为每个高度图添加次序。</p>
<figure>
    <img src="images/Chapter02/DownloadFile_UGUS.png" width="700" height="392" alt="image">
    <figcaption>图：UGUS上下载的TIF高度图均有指定格式：n{纬度}_e{经度}</figcaption>
</figure>

<p>了解上述的答案后，可以开始我们的工作了！</p>
<h2 id="2-1-封装高度数据获取"><a href="#2-1-封装高度数据获取" class="headerlink" title="2.1.封装高度数据获取"></a>2.1.封装高度数据获取</h2><p>为了管理组织高度图数据，我们可以专门封装一个类进行高度数据采样的处理。这个类需要知道地形的尺寸，也需要知道高度图的尺寸，同时还应该持有高度图数据的引用。当拥有地形尺寸与高度图尺寸后，我们就可以根据比例映射获取到地形上某个点应该设置的高度。</p>
<p>所以这个类的关键代码为：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HeightDataManager</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;HeightDataModel&gt; heightDataModels;</span><br><span class="line">    <span class="built_in">int</span> srcWidth;</span><br><span class="line">    <span class="built_in">int</span> srcHeight;</span><br><span class="line">    Vector3Int terrainClusterSize;</span><br><span class="line">    <span class="built_in">int</span> terrainClusterWidth;</span><br><span class="line"><span class="built_in">int</span> terrainClusterHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每当我们为TerrainCluster上的一个点确定高度时，只需要知道这个点相对于Cluster左下角的点的距离，还有该点所在地块的经纬度即可（来确定用哪个HeightDataModel里的数据）。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">SampleFromHeightData</span>(<span class="params"><span class="built_in">int</span> longitude, <span class="built_in">int</span> latitude, Vector3 vertPos, Vector3 clusterStartPoint</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    HeightData heightData = HeightDataModel.GetHeightData(longitude, latitude);</span><br><span class="line">    <span class="keyword">if</span> (heightData != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fixed the vert, because exist cluster offset!</span></span><br><span class="line">        vertPos.x -= clusterStartPoint.x;</span><br><span class="line">        vertPos.z -= clusterStartPoint.z;</span><br><span class="line">        <span class="comment">// resample the size of height map</span></span><br><span class="line">        <span class="built_in">float</span> sx = vertPos.x / terrainClusterWidth * srcWidth;</span><br><span class="line">        <span class="built_in">float</span> sy = vertPos.z / terrainClusterHeight * srcHeight;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> x0 = Mathf.FloorToInt(sx); <span class="comment">//Mathf.Clamp(, 0, srcWidth - 1);</span></span><br><span class="line">        <span class="built_in">int</span> x1 = x0 + <span class="number">1</span>; <span class="comment">// Mathf.Min(, srcWidth - 1);</span></span><br><span class="line">        <span class="built_in">int</span> y0 = Mathf.FloorToInt(sy); <span class="comment">// Mathf.Clamp(, 0, srcHeight - 1); ;</span></span><br><span class="line">        <span class="built_in">int</span> y1 = y0 + <span class="number">1</span>; <span class="comment">// Mathf.Min(, srcHeight - 1);</span></span><br><span class="line">        <span class="built_in">float</span> q00 = GetHeightVal(longitude, latitude, x0, y0, heightData);</span><br><span class="line">        <span class="built_in">float</span> q01 = GetHeightVal(longitude, latitude, x0, y1, heightData);</span><br><span class="line">        <span class="built_in">float</span> q10 = GetHeightVal(longitude, latitude, x1, y0, heightData);</span><br><span class="line">        <span class="built_in">float</span> q11 = GetHeightVal(longitude, latitude, x1, y1, heightData);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">float</span> rx0 = Mathf.Lerp(q00, q10, sx - x0);</span><br><span class="line">        <span class="built_in">float</span> rx1 = Mathf.Lerp(q01, q11, sx - x0);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">float</span> h = Mathf.Lerp(rx0, rx1, sy - y0) * terrainClusterSize.y;</span><br><span class="line">        <span class="built_in">float</span> fixed_h = Mathf.Clamp(h, <span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="keyword">return</span> fixed_h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果直接执行上面的代码，在地形规模大的时候会卡住很久，这是因为我们需要遍历每个顶点为其采样高度，同时又要去每个HeightDataModel下去找该顶点的Cluster的经纬度对应的TIF，所以执行效率会很低。可以使用缓存来减少消耗时间，只需要根据时间局部性原理记录最近采样的TIF文件然后获取到这个字段即可，可直接见源码，此处不记</p>
<p>2.2.设置地块Mesh的高度</p>
<p>设置地形上每个vertex的y值，只需要在Tile的生成Mesh的代码中添加下面这行代码即可</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">Vector3 vert = <span class="keyword">new</span> Vector3(gridSize * i, <span class="number">0</span>, gridSize * j) + startPoint - offsetInMeshVert;</span><br><span class="line"><span class="built_in">float</span> height = heightDataManager.SampleFromHeightData(longitude, latitude, vert, clusterStartPoint);</span><br><span class="line">vert.y = height;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>至于HeightDataModel，可以采用单例或者直接传入Tile那一层来进行调用，如果使用单例：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span>, <span class="title">new</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">GetInstance</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> T();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让HeightDataModel继承上面的类即可</p>
<p>2.3.初步的地貌样式</p>
<p>目前的地形还是一张平面图，是时候应用上我们之前构建的高度图数据了，让它有些高低起伏了。在执行完上面的结果之后会看到以下的地形白膜：</p>
<figure>
    <img src="images/Chapter02/Terrain_Result01.png" width="700" height="392" alt="image">
    <figcaption>图：地形白膜</figcaption>
</figure>


<p>上面的地形中并未做任何着色操作，使用默认材质。同时因为我们生成了法线，所以也可以见到阴影。为了让目前的地形更好看些，可以使用Shader进行些美化。</p>
<p>首先，在生成地形Mesh的时候，根据遍历到的每个顶点的y值（高度），决定该顶点的颜色，最后在shader中应用该颜色。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Color <span class="title">GetColorByHeight</span>(<span class="params"><span class="built_in">float</span> height</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (height &lt; <span class="number">10f</span>)</span><br><span class="line">        <span class="keyword">return</span> lowLandColor; <span class="comment">// 低地</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (height &lt; <span class="number">15f</span>)</span><br><span class="line">        <span class="keyword">return</span> midLandColor; <span class="comment">// 中地</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (height &lt; <span class="number">23f</span>)</span><br><span class="line">        <span class="keyword">return</span> highLandColor; <span class="comment">// 高地</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (height &lt; <span class="number">30f</span>)</span><br><span class="line">        <span class="keyword">return</span> mountainColor; <span class="comment">// 山地</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> snowColor; <span class="comment">// 雪地</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的Shader代码（因为直接采用顶点颜色为其着色，所以很简单）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">    </span><br><span class="line">    CGPROGRAM</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> surface surf Lambert</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> Input</span><br><span class="line">    &#123;</span><br><span class="line">        float2 uv_MainTex;</span><br><span class="line">        float3 worldPos;</span><br><span class="line">        float3 barycentric; <span class="comment">// 添加重心坐标信息</span></span><br><span class="line">        float4 color0 : COLOR; <span class="comment">// 顶点颜色信息</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">surf</span> <span class="params">(Input IN, inout SurfaceOutput o)</span></span><br><span class="line">    &#123;</span><br><span class="line">        float3 vertexColor = IN.barycentric.x * IN.color0.rgb +</span><br><span class="line">                             IN.barycentric.y * IN.color0.rgb +</span><br><span class="line">                             IN.barycentric.z * IN.color0.rgb;</span><br><span class="line">        </span><br><span class="line">        o.Albedo = vertexColor;</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Shader可以生成材质，再通过代码或者直接到MeshRender那里挂接从而生成最终的地形。</p>
<p>本篇日志是最基础的地形搭建，在完成了上述的操作后，使用之前生成的高度图数据，就可以在Editor中生成地形，看到以下有基本地貌的地形，这也就意味着我们迈出了重要的第一步了！</p>
<figure>
    <img src="images/Chapter02/Terrain_Result02.png" width="700" height="392" alt="image">
    <figcaption>图：有基本地貌的地形</figcaption>
</figure> 


      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/12/20/策略游戏地图制作-一-Terrain生成-上/"><span>策略游戏地图制作(一)_Terrain生成_上</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/12/20/策略游戏地图制作-一-Terrain生成-上/" rel="bookmark">
        <time class="entry-date published" datetime="2024-12-19T16:00:00.000Z">
          2024-12-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>一个策略游戏中最重要的部分就是它的地图，地图包含游戏中重要的战略信息，玩家的几乎所有操作都需要与地图的交互进行。而且，身为策略游戏玩家，表现效果丰富的策略地图，也能很好地满足大家指点江山、统筹全局（机枪往前移五米）的愿望。</p>
<p>以下举例一些策略游戏内的地图</p>
<figure>
    <img src="images/Chapter01/EU4_ScreenShot.jpg" width="700" height="392" alt="image">
    <figcaption>图：《欧陆风云4》游戏地图</figcaption>
</figure>

<figure>
    <img src="images/Chapter01/CV6_ScreenShot.jpg" width="700" height="392" alt="image">
    <figcaption>图：《文明6》游戏地图</figcaption>
</figure>

<figure>
    <img src="images/Chapter01/TotalWar_ScreenShot.png" width="700" height="392" alt="image">
    <figcaption>图：《全战三国》游戏地图</figcaption>
</figure>

<p>本系列的开发日志，记录本人制作一个适用于策略游戏开发的地图包，最终目的是开发一个即插即用的地图包，适用于实现策略游戏的地图构建。</p>
<h1 id="1-编辑器界面搭建"><a href="#1-编辑器界面搭建" class="headerlink" title="1.编辑器界面搭建"></a>1.编辑器界面搭建</h1><p>在开始我们的地图开发之前，需要先做一些基建上的准备，比如编辑器。</p>
<p>众所周知，Editor内的工作是面向开发人员的，更要求易用性，同时因为并非GamePlay向，对性能效率的要求往往会低些（可以堆垃圾代码了）。如果你认为直接在Runtime下生成地图内容更方便，也可以跳过本节。但考虑到地图开发是一个很漫长的过程，Editor的辅助也是很重要的，毕竟可视化界面一直是最直观的。<br>Odin编辑器是一个unity编辑器扩展，功能非常强大。本系列的地图开发过程中，使用odin编辑器做Unity内的地图编辑器。可以从Unity商店里的Odin编辑器中获取到资源：<br><a target="_blank" rel="noopener" href="https://assetstore.unity.com/packages/tools/utilities/odin-inspector-and-serializer-89041"></a></p>
<p>以下对编辑器做个简单的封装。<br>继承OdinMenuEditorWindow，继承该类后可以创建编辑器窗口，具备分页效果（示意图可以在后面看到）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 编辑器的 Root，用于初始化编辑器配置</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RootMapEditor</span> : <span class="title">OdinMenuEditorWindow</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立编辑器的入口，之后可以在Unity内上方的ToolBar部分的GameMap项打开</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;GameMap/OpenMapEditor&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenMapEditor</span>()</span> &#123;</span><br><span class="line">    RootMapEditor window = GetWindow&lt;RootMapEditor&gt;(<span class="string">&quot;MapEditor&quot;</span>);</span><br><span class="line">    window.minSize = <span class="keyword">new</span> Vector2(<span class="number">720</span>, <span class="number">320</span>);</span><br><span class="line">    window.Show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>做完上面的操作后，通过GameMap-OpenMapEditor打开的编辑器是一片空白，只有外壳，需要再加上各种子页面。</p>
<p>所以我们添加一个子页面的基类：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BaseMapEditor</span>: <span class="title">ScriptableObject</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>之后的开发中继承实现该类即可添加子页面内容，例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TerrainEditor</span> : <span class="title">BaseMapEditor</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HeightMapEditor</span> : <span class="title">BaseMapEditor</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LandformEditor</span> : <span class="title">BaseMapEditor</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时添加用于初始化地图编辑器的方法，在这个方法中创建各种子页面，并且加入到顶部索引，现在需要通过顶部的GameMap – InitMapEditor来初始化编辑器配置，再打开。（下方代码中的各种文件路径需要自行替换）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;GameMap/InitMapEditor&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitMapEditor</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!AssetDatabase.IsValidFolder(MapStoreEnum.WarGameMapRootPath)) &#123;</span><br><span class="line">        <span class="built_in">string</span> folderName = AssetsUtility.GetInstance().GetFolderFromPath(MapStoreEnum.WarGameMapRootPath);</span><br><span class="line">        AssetDatabase.CreateFolder(MapStoreEnum.WarGameMapRootPath, folderName);</span><br><span class="line">        Debug.Log(<span class="built_in">string</span>.Format(<span class="string">&quot;create file folder : &#123;0&#125;&quot;</span>, MapStoreEnum.MapWindowPath));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> terrainPath = MapStoreEnum.MapWindowPath + <span class="string">&quot;/&quot;</span> + MapEditorClass.TerrainClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!AssetDatabase.IsValidFolder(terrainPath)) &#123;</span><br><span class="line">        AssetDatabase.CreateFolder(MapStoreEnum.MapWindowPath, MapEditorClass.TerrainClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get HashSet(window objs name) in folders</span></span><br><span class="line">    HashSet&lt;<span class="built_in">string</span>&gt; terrainFileNames = GetFileNames(terrainPath);</span><br><span class="line">    <span class="comment">// create window scriptableObject</span></span><br><span class="line">    <span class="keyword">if</span> (!terrainFileNames.Contains(MapEditorEnum.TerrainEditor)) &#123;</span><br><span class="line">        CreateWindowObj&lt;TerrainEditor&gt;(MapEditorClass.TerrainClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!terrainFileNames.Contains(MapEditorEnum.LandformEditor)) &#123;</span><br><span class="line">        CreateWindowObj&lt;LandformEditor&gt;(MapEditorClass.TerrainClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!terrainFileNames.Contains(MapEditorEnum.HeightMapEditor)) &#123;</span><br><span class="line">        CreateWindowObj&lt;HeightMapEditor&gt;(MapEditorClass.TerrainClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!terrainFileNames.Contains(MapEditorEnum.HexMapEditor)) &#123;</span><br><span class="line">        CreateWindowObj&lt;HexmapEditor&gt;(MapEditorClass.TerrainClass);</span><br><span class="line">    &#125;</span><br><span class="line">    AssetDatabase.SaveAssets();</span><br><span class="line">    AssetDatabase.Refresh();</span><br><span class="line">    Debug.Log(<span class="string">&quot;成功初始化 MapEditor, 现在可以打开编辑器!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>两个辅助方法，用于获取完整的文件名称、创建子页面物体：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> HashSet&lt;<span class="built_in">string</span>&gt; <span class="title">GetFileNames</span>(<span class="params"><span class="built_in">string</span> folderPath</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">string</span>[] guids = AssetDatabase.FindAssets(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span>[] &#123; folderPath &#125;);</span><br><span class="line">      HashSet&lt;<span class="built_in">string</span>&gt; terrainFileNames = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">      <span class="keyword">foreach</span> (<span class="keyword">var</span> guid <span class="keyword">in</span> guids) &#123;</span><br><span class="line">            <span class="built_in">string</span> path = AssetDatabase.GUIDToAssetPath(guid);</span><br><span class="line">            <span class="built_in">string</span> fileName = System.IO.Path.GetFileNameWithoutExtension(path);</span><br><span class="line">            terrainFileNames.Add(fileName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> terrainFileNames;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateWindowObj</span>&lt;<span class="title">MapEditor</span>&gt;(<span class="params"><span class="built_in">string</span> windowClass</span>) <span class="keyword">where</span> MapEditor : BaseMapEditor</span> &#123;</span><br><span class="line">      <span class="built_in">string</span> rootWindowPath = MapStoreEnum.MapWindowPath + <span class="string">&quot;/&quot;</span> + windowClass + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">      MapEditor asset = ScriptableObject.CreateInstance&lt;MapEditor&gt;();</span><br><span class="line">      asset.name = asset.EditorName + <span class="string">&quot;.asset&quot;</span>;</span><br><span class="line">      <span class="built_in">string</span> path = rootWindowPath + asset.name;</span><br><span class="line">      Debug.Log(<span class="string">&quot;create path: &quot;</span> + path);</span><br><span class="line">      AssetDatabase.CreateAsset(asset, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>添加上各种功能后的编辑器效果，如下图所示（下图是填充了部分内容的，如果你没有在Window内添加内容，那么依然会显示一片空白）。</p>
<figure>
    <img src="images/Chapter01/Editor_Full.png" width="700" height="392" alt="image">
    <figcaption>图：填充内容后的MapEditor</figcaption>
</figure>

<p>看起来还挺完整的，那么第一步就成功迈出了</p>
<p>如果你依然对Odin编辑器的其他部分感兴趣，可以看看以下的教程&#x2F;文档:<br><a target="_blank" rel="noopener" href="https://github.com/su9257/Odin-Inspector-Chinese-Tutorial"></a><br><a href=" https://odininspector.com/documentation"></a></p>
<h1 id="2-Terrain数据组织"><a href="#2-Terrain数据组织" class="headerlink" title="2.Terrain数据组织"></a>2.Terrain数据组织</h1><p>在Unity中有内置的Terrain系统，它是Unity官方提供的一套地形系统，可以直接在Inspector中刷地形。支持URP和HDRP，源码在C++层中，意味着个人开发者无法定制Terrain的细节。与Mesh的渲染不同，Terrain新开了一个Pass去处理，做了很多优化与适配。Terrain在移动端的性能表现并不好，在移动端制作地形依然偏向使用Mesh的方案，Mesh是适用性更广的工作流，突出一个思想简单，所以此处会使用Mesh实现地形。</p>
<figure>
    <img src="images/Chapter01/Unity_TerrainSystem.png" width="700" height="392" alt="image">
    <figcaption>图：使用Unity内置的Terrain系统</figcaption>
</figure>


<h2 id="2-1-地块分块处理"><a href="#2-1-地块分块处理" class="headerlink" title="2.1.地块分块处理"></a>2.1.地块分块处理</h2><h3 id="2-1-1-为什么要分块"><a href="#2-1-1-为什么要分块" class="headerlink" title="2.1.1.为什么要分块"></a>2.1.1.为什么要分块</h3><p>在大地图游戏中，对地图的分块处理是基操。在超大规模的地图离，通常将地图数据分为一个个Chunk，根据玩家的位置加载周围的Chunk。对地图分块，利于我们进行动态加载、剔除等操作，实现内存等方面的优化，更好管理地图数据。</p>
<p>以《艾尔登法环》为例，法环的地图总面积约为100平方千米，游戏中划分的最小网格单元为256m×256m，也会有更大一些的比如1024m×1024m的网格划分，这样可以对游戏内地图的总体网格数进行适当性的控制，同时保持远景的加载质量。 </p>
<figure>
    <img src="images/Chapter01/EldenRing_PPT.png" width="700" height="392" alt="image">
    <figcaption>图：《艾尔登法环》在2022年GDC中的汇报</figcaption>
</figure>
 
<p>而在策略游戏中，因为策略游戏一般是2.5D制作，地图往往是平面的，相比法环之类的大制作，在地图上考虑的东西要更少些，比如不需要考虑纵深结构。</p>
<p>我们在此简单地将地图块，划分成两层：世界地形会由多个Cluster组成，一个Cluster内置多个Tile，如下图所示：</p>
<figure>
    <img src="images/Chapter01/TerrainDivide_Model.png" width="700" height="392" alt="image">
    <figcaption>图：地形分块的简单模型</figcaption>
</figure>

<h3 id="2-1-2-地块分块模型"><a href="#2-1-2-地块分块模型" class="headerlink" title="2.1.2.地块分块模型"></a>2.1.2.地块分块模型</h3><p>在此简单阐述下地图模块中Terrain的分块模型：<br>-TerrainCluster：对应一个TIF文件，即一个现实中的地块<br>-TerrainTile：在Cluster的基础上进一步的划分，可以用于后续实现更细致的LOD切换</p>
<p>以下是两个地块单位的关键部分代码（注：以下关于LOD的字段可以先添加，后续建LOD的时候再使用）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TerrainCluster</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> idxX &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> idxY &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> longitude &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> latitude &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    Vector3Int terrainClusterSize;</span><br><span class="line">    <span class="built_in">int</span> tileSize;</span><br><span class="line">    TDList&lt;TerrainTile&gt; terrainTileList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TerrainTile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> tileIdxX &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> tileIdxY &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> longitude &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> latitude &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> curLODLevel &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    Vector3 clusterStartPoint;</span><br><span class="line">    <span class="built_in">int</span> tileSize;</span><br><span class="line">    <span class="built_in">int</span>[] LODLevels;</span><br><span class="line">    MeshData[] LODMeshes;</span><br><span class="line">    <span class="keyword">public</span> Vector3 tileCenterPos &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> MeshFilter meshFilter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-2-建立地块类"><a href="#2-2-建立地块类" class="headerlink" title="2.2.建立地块类"></a>2.2.建立地块类</h2><p>在完成上述的地块数据建模之后，我们可以开始构建地形Mesh了，下面代码用于建立TerrainCluster，缺失的字段直接补充即可</p>
<p>注：以下代码是较早的版本，查看最新版本代码请到：<br><a target="_blank" rel="noopener" href="https://github.com/huayuxingtguiyujing/WarGameMap"></a><br>注：建议直接跳过本节的TerrainCluster与TerrainTile构建，到下一节的地形Mesh构建</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitHeightCons</span>(<span class="params">Vector3Int terrainSize, Vector3Int clusterSize, <span class="built_in">int</span> tileSize, <span class="built_in">int</span> LODLevel, List&lt;HeightDataModel&gt; heightDataModels</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.terrainSize = terrainSize;</span><br><span class="line">    <span class="keyword">this</span>.clusterSize = clusterSize;</span><br><span class="line">    <span class="keyword">this</span>.tileSize = tileSize;</span><br><span class="line">    <span class="keyword">this</span>.LODLevel = LODLevel;</span><br><span class="line">    clusterWidth = terrainSize.x;</span><br><span class="line">    clusterHeight = terrainSize.z;</span><br><span class="line">    clusterList = <span class="keyword">new</span> TDList&lt;TerrainCluster&gt;(clusterWidth, clusterHeight);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;  i &lt; clusterHeight; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>;  j &lt; clusterWidth; j++) &#123;</span><br><span class="line">            GameObject clusterGo = CreateHeightCluster(i, j);</span><br><span class="line">            clusterList[i, j].InitTerrainCluster(……);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面的代码中，创建地形Mesh数据会分配大量内存，如果地形过大可能会炸，同时因为过程是同步的，如果创建的地块数量太多，会卡很久。所以这里建议使用懒初始化去构建地形，方法很简单，在需要这块地块的时候再创建地块的Mesh即可，此处暂时不记。</p>
<p>TerrainCluster中的InitTerrainCluster初始化方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitTerrainCluster</span>(<span class="params"><span class="built_in">int</span> idxX, <span class="built_in">int</span> idxY, <span class="built_in">int</span> longitude, <span class="built_in">int</span> latitude, Vector3Int terrainClusterSize, <span class="built_in">int</span> tileSize, <span class="built_in">int</span> LODLevel, GameObject clusterGo</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.idxX = idxX;</span><br><span class="line">    <span class="keyword">this</span>.idxY = idxY;</span><br><span class="line">    <span class="keyword">this</span>.longitude = longitude;</span><br><span class="line">    <span class="keyword">this</span>.latitude = latitude;</span><br><span class="line">    <span class="keyword">this</span>.terrainClusterSize = terrainClusterSize;</span><br><span class="line">    <span class="keyword">this</span>.tileSize = tileSize;</span><br><span class="line">    <span class="keyword">this</span>.LODLevel = LODLevel;</span><br><span class="line">    <span class="keyword">this</span>.clusterGo = clusterGo;</span><br><span class="line">    Vector3 startPoint = <span class="keyword">new</span> Vector3(terrainClusterSize.x * idxX, <span class="number">0</span>, terrainClusterSize.z * idxY);</span><br><span class="line">    InitTerrainCluster(startPoint);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitTerrainCluster</span>(<span class="params">Vector3 clusterStartPoint</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> tileNumPerLine = terrainClusterSize.x / tileSize;</span><br><span class="line">    terrainTileList = <span class="keyword">new</span> TDList&lt;TerrainTile&gt;(tileNumPerLine, tileNumPerLine);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tileNumPerLine; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; tileNumPerLine; j++) &#123;</span><br><span class="line">            MeshFilter meshFilter = CreateHeightTile(i, j);</span><br><span class="line">            terrainTileList[i, j].InitTileMeshData(i, j, longitude, latitude, clusterStartPoint, meshFilter,  lodLevels);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// generate mesh data </span></span><br><span class="line">        <span class="built_in">int</span> vertexNumFix = (<span class="built_in">int</span>)Mathf.Pow(<span class="number">2</span>, LODLevel );</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tileNumPerLine; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; tileNumPerLine; j++) &#123;</span><br><span class="line">                terrainTileList[i, j]. InitTerrainTile( tileSize, vertexNumFix, terrainClusterSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curLODLevel--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CreateHeightTile：用于创建一个游戏物体，代表一个Cluster，可以放置Mesh渲染组件，获取到MeshFilter作为Cluster的字段</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MeshFilter <span class="title">CreateHeightTile</span>(<span class="params"><span class="built_in">int</span> idxX, <span class="built_in">int</span> idxY</span>)</span> &#123;</span><br><span class="line">    GameObject tileGo = <span class="keyword">new</span> GameObject();</span><br><span class="line">    tileGo.transform.parent = clusterGo.transform;</span><br><span class="line">    tileGo.name = <span class="built_in">string</span>.Format(<span class="string">&quot;heightTile_&#123;0&#125;_&#123;1&#125;&quot;</span>, idxX, idxY);</span><br><span class="line">    MeshFilter meshFilter = tileGo.AddComponent&lt;MeshFilter&gt;();</span><br><span class="line">    tileGo.AddComponent&lt;MeshRenderer&gt;();</span><br><span class="line">    <span class="keyword">return</span> meshFilter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>TerrainTile中的InitTileMeshData初始化方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitTileMeshData</span>(<span class="params"><span class="built_in">int</span> idxX, <span class="built_in">int</span> idxY, <span class="built_in">int</span> longitude, <span class="built_in">int</span> latitude, Vector3 startPoint, MeshFilter meshFilter,<span class="built_in">int</span>[] lODLevels</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.clusterStartPoint = startPoint;</span><br><span class="line">    <span class="keyword">this</span>.meshFilter = meshFilter;</span><br><span class="line">    tileIdxX = idxX;</span><br><span class="line">    tileIdxY = idxY;</span><br><span class="line">    <span class="keyword">this</span>.longitude = longitude;</span><br><span class="line">    <span class="keyword">this</span>.latitude = latitude;</span><br><span class="line">    curLODLevel = <span class="number">-1</span>;       <span class="comment">// init as -1</span></span><br><span class="line">    LODLevels = lODLevels;</span><br><span class="line">    LODMeshes = <span class="keyword">new</span> MeshData[lODLevels.Length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-3-地形Mesh构建"><a href="#2-3-地形Mesh构建" class="headerlink" title="2.3.地形Mesh构建"></a>2.3.地形Mesh构建</h2><h3 id="2-3-1-MeshData数据类"><a href="#2-3-1-MeshData数据类" class="headerlink" title="2.3.1.MeshData数据类"></a>2.3.1.MeshData数据类</h3><p>最后是关键的构建Mesh的部分代码，我们为地形Tile专门写一个Mesh数据类，以下是它需要包含的字段</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MeshData</span> &#123;</span><br><span class="line">    Vector3[] vertexs = <span class="keyword">new</span> Vector3[<span class="number">1</span>];</span><br><span class="line">    Vector3[] fixedVertexs = <span class="keyword">new</span> Vector3[<span class="number">1</span>];			<span class="comment">// use to fix LOD seam</span></span><br><span class="line">    Vector3[] outofMeshVertexs = <span class="keyword">new</span> Vector3[<span class="number">1</span>];</span><br><span class="line">    Vector3[] fixedOutMeshVertexs = <span class="keyword">new</span> Vector3[<span class="number">1</span>];	<span class="comment">// use to fix LOD seam</span></span><br><span class="line">    <span class="built_in">int</span>[,] vertexIndiceMap = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">1</span>, <span class="number">1</span>];  <span class="comment">// map the (x, y) to index in vertexs/outofMeshVertexs</span></span><br><span class="line">    Vector3[] normals = <span class="keyword">new</span> Vector3[<span class="number">1</span>];</span><br><span class="line">    Vector2[] uvs = <span class="keyword">new</span> Vector2[<span class="number">1</span>];</span><br><span class="line">    Color[] colors = <span class="keyword">new</span> Color[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">int</span>[] triangles = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">int</span>[] outOfMeshTriangles = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>构建一个Mesh最基本的要素就是：<br>-Vertexs：顶点数组，最基本的要素<br>-Normals：法线数组，用于shader操作，实现正确的地图阴影和光照<br>-Uvs：纹理坐标，用于后续实现地形纹理在地形上的映射<br>-Colors：顶点颜色数组，如果shader不使用color的话可以不做设置，此处作为占位符</p>
<p>所以MeshData包含了上述字段，而值得注意的是这里使用了outofMeshVertexs数组来记录地形Mesh外的数据，这是因为每个地块边缘的顶点都需要额外地计算外面一层的片元，否则边缘顶点的法线计算会出现问题（因为只计算了本地块的三角型对法线的贡献），不同地块的的衔接处会出现明显的界限。</p>
<p>如下图所示，边缘虚线的顶点存储在outofMeshVertex中，不会用于构建Tile地块，也会存储额外的边缘三角型信息</p>
<figure>
    <img src="images/Chapter01/MoreVert_BuildMesh.png" width="700" height="392" alt="image">
    <figcaption>图：存储额外的顶点用于构建Mesh</figcaption>
</figure>

<h3 id="2-3-2-添加顶点"><a href="#2-3-2-添加顶点" class="headerlink" title="2.3.2.添加顶点"></a>2.3.2.添加顶点</h3><p>往MeshData中添加顶点和片元索引的方法。会根据一个外部的传入参数vertexIndex来决定要添加的顶点是Tile内的，还是在OutofMesh的，外部参数在后面的构建Mesh部分可见。三角型片元一样需要判断该片元是内部的还是外部的</p>
<p>此处参考了一个开源的游戏地形构建方案，可以结合此链接学习：<br><a href = "https://github.com/SebLague/Procedural-Landmass-Generation"></a></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddVertex</span>(<span class="params">Vector3 vertexPosition, Vector2 uv, <span class="built_in">int</span> vertIndex</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (vertIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        outofMeshVertexs[- vertIndex - <span class="number">1</span>] = vertexPosition;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vertexs[vertIndex] = vertexPosition;</span><br><span class="line">        uvs[vertIndex] = uv;</span><br><span class="line">        normals[vertIndex] = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        colors[vertIndex] = GetColorByHeight(vertexPosition.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddTriangle</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b, <span class="built_in">int</span> c, <span class="built_in">int</span> i = <span class="number">0</span>, <span class="built_in">int</span> j = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span> || c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (outOfMeshTriangleIndex + <span class="number">1</span> &gt; outOfMeshTriangles.Length - <span class="number">1</span>) &#123;</span><br><span class="line">            Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;triangle idx : &#123;0&#125;, &#123;1&#125; !&quot;</span>, i, j));</span><br><span class="line">            Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;out of bound! cur idx : &#123;0&#125;, cur a : &#123;1&#125;, cur b : &#123;2&#125;, cur c : &#123;3&#125;, length : &#123;4&#125;&quot;</span>, outOfMeshTriangleIndex, a, b, c, outOfMeshTriangles.Length));</span><br><span class="line">        &#125;</span><br><span class="line">        outOfMeshTriangles[outOfMeshTriangleIndex] = a;</span><br><span class="line">        outOfMeshTriangles[outOfMeshTriangleIndex + <span class="number">1</span>] = b;</span><br><span class="line">        outOfMeshTriangles[outOfMeshTriangleIndex + <span class="number">2</span>] = c;</span><br><span class="line">        outOfMeshTriangleIndex += <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        triangles[triangleIndex] = a;</span><br><span class="line">        triangles[triangleIndex + <span class="number">1</span>] = b;</span><br><span class="line">        triangles[triangleIndex + <span class="number">2</span>] = c;</span><br><span class="line">        triangleIndex += <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-3-构建Mesh"><a href="#2-3-3-构建Mesh" class="headerlink" title="2.3.3.构建Mesh"></a>2.3.3.构建Mesh</h3><p>在Tile中构建Mesh逻辑如下，代码放置到TerrainTile中。根据传入的LOD级别（下一节会讲）、Tile的size，每个Tile地形一行应该有的Vertex数目，来共同构建一个TileMesh</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetMeshData</span>(<span class="params"><span class="built_in">int</span> curLODLevel, <span class="built_in">int</span> tileSize, <span class="built_in">int</span> vertexNumFix, Vector3Int terrainClusterSize</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.tileSize = tileSize;</span><br><span class="line">    <span class="comment">// caculate tile&#x27;s start point</span></span><br><span class="line">    <span class="built_in">float</span> startX = tileIdxX * tileSize;</span><br><span class="line">    <span class="built_in">float</span> startZ = tileIdxY * tileSize;</span><br><span class="line">    Vector3 startPoint = <span class="keyword">new</span> Vector3(startX, <span class="number">0</span>, startZ) + <span class="keyword">this</span>.clusterStartPoint;       <span class="comment">// </span></span><br><span class="line">tileCenterPos = startPoint + <span class="keyword">new</span> Vector3(tileSize / <span class="number">2</span>, <span class="number">0</span>, tileSize / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">int</span> gridNumPerLine = tileSize / vertexNumFix;</span><br><span class="line">    <span class="built_in">int</span> gridSize = tileSize / gridNumPerLine;</span><br><span class="line">    <span class="built_in">int</span> vertexPerLine = tileSize / vertexNumFix + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> gridNumPerLineFixed = gridNumPerLine + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int</span> vertexPerLineFixed = vertexPerLine + <span class="number">2</span>;</span><br><span class="line">    LODMeshes[curLODLevel] = <span class="keyword">new</span> MeshData();</span><br><span class="line">    MeshData meshData = LODMeshes[curLODLevel];</span><br><span class="line">    meshData.InitMeshData(gridNumPerLine, gridNumPerLineFixed, vertexPerLine, vertexPerLineFixed);</span><br><span class="line">    <span class="built_in">int</span> curInVertIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> curOutVertIdx = <span class="number">-1</span>;</span><br><span class="line">    Vector3 offsetInMeshVert = <span class="keyword">new</span> Vector3(gridSize, <span class="number">0</span>, gridSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; vertexPerLineFixed; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; vertexPerLineFixed; j++) &#123;</span><br><span class="line">            <span class="built_in">bool</span> isVertOutOfMesh = (i == <span class="number">0</span>) || (i == vertexPerLineFixed - <span class="number">1</span>) || (j == <span class="number">0</span>) || (j == vertexPerLineFixed - <span class="number">1</span>);</span><br><span class="line">            Vector3 vert = <span class="keyword">new</span> Vector3(gridSize * i, <span class="number">0</span>, gridSize * j) + startPoint - offsetInMeshVert;</span><br><span class="line">            <span class="comment">//float height = 0;</span></span><br><span class="line">            vert.y = height;</span><br><span class="line">            Vector2 uv = <span class="keyword">new</span> Vector2(vert.x / terrainClusterSize.x, vert.z / terrainClusterSize.z);</span><br><span class="line">            <span class="keyword">if</span> (isVertOutOfMesh) &#123;</span><br><span class="line">                meshData.AddVertex(vert, uv, curOutVertIdx);</span><br><span class="line">                meshData.SetIndiceInMap(i, j, curOutVertIdx);</span><br><span class="line">                <span class="comment">//vertexIndiceMap[i, j] = curOutVertIdx;</span></span><br><span class="line">                curOutVertIdx --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                meshData.AddVertex(vert, uv, curInVertIdx);</span><br><span class="line">                meshData.SetIndiceInMap(i, j, curInVertIdx);</span><br><span class="line">                <span class="comment">//vertexIndiceMap[i, j] = curInVertIdx;</span></span><br><span class="line">                curInVertIdx ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> curGridIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; gridNumPerLineFixed; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; gridNumPerLineFixed; j++) &#123;</span><br><span class="line">            <span class="comment">// i, j 是当前遍历到的 grid 的 index</span></span><br><span class="line">            <span class="built_in">int</span> cur_w = curGridIdx % gridNumPerLineFixed;</span><br><span class="line">            <span class="built_in">int</span> cur_h = curGridIdx / gridNumPerLineFixed;</span><br><span class="line">            <span class="built_in">int</span> next_w = cur_w + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> next_h = cur_h + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> a = meshData.GetIndiceInMap(cur_w, cur_h);</span><br><span class="line">            <span class="built_in">int</span> b = meshData.GetIndiceInMap(cur_w, next_h);</span><br><span class="line">            <span class="built_in">int</span> c = meshData.GetIndiceInMap(next_w, next_h);</span><br><span class="line">            <span class="built_in">int</span> d = meshData.GetIndiceInMap(next_w, cur_h);</span><br><span class="line">            meshData.AddTriangle(a, b, c, i, j);</span><br><span class="line">            meshData.AddTriangle(a, c, d, i, j);</span><br><span class="line">            curGridIdx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    meshData.RecaculateNormal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-4-计算法线"><a href="#2-3-4-计算法线" class="headerlink" title="2.3.4.计算法线"></a>2.3.4.计算法线</h3><p>先前一直在强调，要记录OutOfMesh即Tile地块外部的，这一操作就是为了正确地计算法线，计算法线的代码如下：<br>此处代码源自（伟大的作者！）：<br><a href = "https://github.com/SebLague/Procedural-Landmass-Generation/blob/master/Proc%20Gen%20E21/Assets/Scripts/MeshGenerator.cs"></a></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RecaculateNormal</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> triangleCount = triangles.Length / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; triangleCount; i++) &#123;</span><br><span class="line">        <span class="built_in">int</span> normalTriangleIndex = i * <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> vertexIndexA = triangles[normalTriangleIndex];</span><br><span class="line">        <span class="built_in">int</span> vertexIndexB = triangles[normalTriangleIndex + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">int</span> vertexIndexC = triangles[normalTriangleIndex + <span class="number">2</span>];</span><br><span class="line">        Vector3 triangleNormal = SurfaceNormalFromIndices(vertexIndexA, vertexIndexB, vertexIndexC);</span><br><span class="line">        <span class="comment">//Vector3 triangleNormal = SurfaceNormalFromIndices_Fixed(vertexIndexA, vertexIndexB, vertexIndexC);</span></span><br><span class="line">        normals[vertexIndexA] += triangleNormal;</span><br><span class="line">        normals[vertexIndexB] += triangleNormal;</span><br><span class="line">        normals[vertexIndexC] += triangleNormal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// border triangle, caculate their value to normal</span></span><br><span class="line">    <span class="built_in">int</span> borderTriangleCount = outOfMeshTriangles.Length / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; borderTriangleCount; i++) &#123;</span><br><span class="line">        <span class="built_in">int</span> normalTriangleIndex = i * <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> vertexIndexA = outOfMeshTriangles[normalTriangleIndex];</span><br><span class="line">        <span class="built_in">int</span> vertexIndexB = outOfMeshTriangles[normalTriangleIndex + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">int</span> vertexIndexC = outOfMeshTriangles[normalTriangleIndex + <span class="number">2</span>];</span><br><span class="line">        Vector3 triangleNormal = SurfaceNormalFromIndices(vertexIndexA, vertexIndexB, vertexIndexC);</span><br><span class="line">        <span class="comment">//Vector3 triangleNormal = SurfaceNormalFromIndices_Fixed(vertexIndexA, vertexIndexB, vertexIndexC);</span></span><br><span class="line">        <span class="keyword">if</span> (vertexIndexA &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            normals[vertexIndexA] += triangleNormal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vertexIndexB &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            normals[vertexIndexB] += triangleNormal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vertexIndexC &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            normals[vertexIndexC] += triangleNormal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; normals.Length; i++) &#123;</span><br><span class="line">        normals[i].Normalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在联通了TerrainCluster与TerrainTile的执行逻辑后，通过odin编辑器或者其他途径生成每个Tile的Mesh，此处的编辑器代码暂不提供，因为关键的逻辑已经写完，如何调用这些方法都是次要的了； </p>
<p>此时我们已经构建了一个基础地形，如果上述步骤全部通过，它在scene中会是这样的平面：</p>
<figure>
    <img src="images/Chapter01/Terrain_Result.png" width="700" height="392" alt="image">
    <figcaption>图：生成的地形Mesh</figcaption>
</figure>

<p>还远远不够！</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2025 Nobody
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>