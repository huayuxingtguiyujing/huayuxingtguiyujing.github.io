<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>策略游戏地图制作(一)_Terrain生成_上 | 记录游戏开发历程</title>

  
  <meta name="author" content="Nobody">
  

  
  <meta name="description" content="一个策略游戏中最重要的部分就是它的地图，地图包含游戏中重要的战略信息，玩家的几乎所有操作都需要与地图的交互进行。而且，身为策略游戏玩家，表现效果丰富的策略地图，也能很好地满足大家指点江山、统筹全局（机枪往前移五米）的愿望。
以下举例一些策略游戏内的地图

    
    图：《欧陆风云4》游戏地图">
  

  
  
  <meta name="keywords" content="">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="策略游戏地图制作(一)_Terrain生成_上"/>

  <meta property="og:site_name" content="记录游戏开发历程"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="记录游戏开发历程" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">记录游戏开发历程</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>策略游戏地图制作(一)_Terrain生成_上</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/12/20/策略游戏地图制作-一-Terrain生成-上/" rel="bookmark">
        <time class="entry-date published" datetime="2024-12-19T16:00:00.000Z">
          2024-12-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>一个策略游戏中最重要的部分就是它的地图，地图包含游戏中重要的战略信息，玩家的几乎所有操作都需要与地图的交互进行。而且，身为策略游戏玩家，表现效果丰富的策略地图，也能很好地满足大家指点江山、统筹全局（机枪往前移五米）的愿望。</p>
<p>以下举例一些策略游戏内的地图</p>
<figure>
    <img src="images/Chapter01/EU4_ScreenShot.jpg" width="700" height="392" alt="image">
    <figcaption>图：《欧陆风云4》游戏地图</figcaption>
</figure>

<figure>
    <img src="images/Chapter01/CV6_ScreenShot.jpg" width="700" height="392" alt="image">
    <figcaption>图：《文明6》游戏地图</figcaption>
</figure>

<figure>
    <img src="images/Chapter01/TotalWar_ScreenShot.png" width="700" height="392" alt="image">
    <figcaption>图：《全战三国》游戏地图</figcaption>
</figure>

<p>本系列的开发日志，记录本人制作一个适用于策略游戏开发的地图包，最终目的是开发一个即插即用的地图包，适用于实现策略游戏的地图构建。</p>
<h1 id="1-编辑器界面搭建"><a href="#1-编辑器界面搭建" class="headerlink" title="1.编辑器界面搭建"></a>1.编辑器界面搭建</h1><p>在开始我们的地图开发之前，需要先做一些基建上的准备，比如编辑器。</p>
<p>众所周知，Editor内的工作是面向开发人员的，更要求易用性，同时因为并非GamePlay向，对性能效率的要求往往会低些（可以堆垃圾代码了）。如果你认为直接在Runtime下生成地图内容更方便，也可以跳过本节。但考虑到地图开发是一个很漫长的过程，Editor的辅助也是很重要的，毕竟可视化界面一直是最直观的。<br>Odin编辑器是一个unity编辑器扩展，功能非常强大。本系列的地图开发过程中，使用odin编辑器做Unity内的地图编辑器。可以从Unity商店里的Odin编辑器中获取到资源：<br><a target="_blank" rel="noopener" href="https://assetstore.unity.com/packages/tools/utilities/odin-inspector-and-serializer-89041"></a></p>
<p>以下对编辑器做个简单的封装。<br>继承OdinMenuEditorWindow，继承该类后可以创建编辑器窗口，具备分页效果（示意图可以在后面看到）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 编辑器的 Root，用于初始化编辑器配置</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RootMapEditor</span> : <span class="title">OdinMenuEditorWindow</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立编辑器的入口，之后可以在Unity内上方的ToolBar部分的GameMap项打开</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;GameMap/OpenMapEditor&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenMapEditor</span>()</span> &#123;</span><br><span class="line">    RootMapEditor window = GetWindow&lt;RootMapEditor&gt;(<span class="string">&quot;MapEditor&quot;</span>);</span><br><span class="line">    window.minSize = <span class="keyword">new</span> Vector2(<span class="number">720</span>, <span class="number">320</span>);</span><br><span class="line">    window.Show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>做完上面的操作后，通过GameMap-OpenMapEditor打开的编辑器是一片空白，只有外壳，需要再加上各种子页面。</p>
<p>所以我们添加一个子页面的基类：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BaseMapEditor</span>: <span class="title">ScriptableObject</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>之后的开发中继承实现该类即可添加子页面内容，例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TerrainEditor</span> : <span class="title">BaseMapEditor</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HeightMapEditor</span> : <span class="title">BaseMapEditor</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LandformEditor</span> : <span class="title">BaseMapEditor</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时添加用于初始化地图编辑器的方法，在这个方法中创建各种子页面，并且加入到顶部索引，现在需要通过顶部的GameMap – InitMapEditor来初始化编辑器配置，再打开。（下方代码中的各种文件路径需要自行替换）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;GameMap/InitMapEditor&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitMapEditor</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!AssetDatabase.IsValidFolder(MapStoreEnum.WarGameMapRootPath)) &#123;</span><br><span class="line">        <span class="built_in">string</span> folderName = AssetsUtility.GetInstance().GetFolderFromPath(MapStoreEnum.WarGameMapRootPath);</span><br><span class="line">        AssetDatabase.CreateFolder(MapStoreEnum.WarGameMapRootPath, folderName);</span><br><span class="line">        Debug.Log(<span class="built_in">string</span>.Format(<span class="string">&quot;create file folder : &#123;0&#125;&quot;</span>, MapStoreEnum.MapWindowPath));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> terrainPath = MapStoreEnum.MapWindowPath + <span class="string">&quot;/&quot;</span> + MapEditorClass.TerrainClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!AssetDatabase.IsValidFolder(terrainPath)) &#123;</span><br><span class="line">        AssetDatabase.CreateFolder(MapStoreEnum.MapWindowPath, MapEditorClass.TerrainClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get HashSet(window objs name) in folders</span></span><br><span class="line">    HashSet&lt;<span class="built_in">string</span>&gt; terrainFileNames = GetFileNames(terrainPath);</span><br><span class="line">    <span class="comment">// create window scriptableObject</span></span><br><span class="line">    <span class="keyword">if</span> (!terrainFileNames.Contains(MapEditorEnum.TerrainEditor)) &#123;</span><br><span class="line">        CreateWindowObj&lt;TerrainEditor&gt;(MapEditorClass.TerrainClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!terrainFileNames.Contains(MapEditorEnum.LandformEditor)) &#123;</span><br><span class="line">        CreateWindowObj&lt;LandformEditor&gt;(MapEditorClass.TerrainClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!terrainFileNames.Contains(MapEditorEnum.HeightMapEditor)) &#123;</span><br><span class="line">        CreateWindowObj&lt;HeightMapEditor&gt;(MapEditorClass.TerrainClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!terrainFileNames.Contains(MapEditorEnum.HexMapEditor)) &#123;</span><br><span class="line">        CreateWindowObj&lt;HexmapEditor&gt;(MapEditorClass.TerrainClass);</span><br><span class="line">    &#125;</span><br><span class="line">    AssetDatabase.SaveAssets();</span><br><span class="line">    AssetDatabase.Refresh();</span><br><span class="line">    Debug.Log(<span class="string">&quot;成功初始化 MapEditor, 现在可以打开编辑器!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>两个辅助方法，用于获取完整的文件名称、创建子页面物体：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> HashSet&lt;<span class="built_in">string</span>&gt; <span class="title">GetFileNames</span>(<span class="params"><span class="built_in">string</span> folderPath</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">string</span>[] guids = AssetDatabase.FindAssets(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span>[] &#123; folderPath &#125;);</span><br><span class="line">      HashSet&lt;<span class="built_in">string</span>&gt; terrainFileNames = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">      <span class="keyword">foreach</span> (<span class="keyword">var</span> guid <span class="keyword">in</span> guids) &#123;</span><br><span class="line">            <span class="built_in">string</span> path = AssetDatabase.GUIDToAssetPath(guid);</span><br><span class="line">            <span class="built_in">string</span> fileName = System.IO.Path.GetFileNameWithoutExtension(path);</span><br><span class="line">            terrainFileNames.Add(fileName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> terrainFileNames;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateWindowObj</span>&lt;<span class="title">MapEditor</span>&gt;(<span class="params"><span class="built_in">string</span> windowClass</span>) <span class="keyword">where</span> MapEditor : BaseMapEditor</span> &#123;</span><br><span class="line">      <span class="built_in">string</span> rootWindowPath = MapStoreEnum.MapWindowPath + <span class="string">&quot;/&quot;</span> + windowClass + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">      MapEditor asset = ScriptableObject.CreateInstance&lt;MapEditor&gt;();</span><br><span class="line">      asset.name = asset.EditorName + <span class="string">&quot;.asset&quot;</span>;</span><br><span class="line">      <span class="built_in">string</span> path = rootWindowPath + asset.name;</span><br><span class="line">      Debug.Log(<span class="string">&quot;create path: &quot;</span> + path);</span><br><span class="line">      AssetDatabase.CreateAsset(asset, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>添加上各种功能后的编辑器效果，如下图所示（下图是填充了部分内容的，如果你没有在Window内添加内容，那么依然会显示一片空白）。</p>
<figure>
    <img src="images/Chapter01/Editor_Full.png" width="700" height="392" alt="image">
    <figcaption>图：填充内容后的MapEditor</figcaption>
</figure>

<p>看起来还挺完整的，那么第一步就成功迈出了</p>
<p>如果你依然对Odin编辑器的其他部分感兴趣，可以看看以下的教程&#x2F;文档:<br><a target="_blank" rel="noopener" href="https://github.com/su9257/Odin-Inspector-Chinese-Tutorial"></a><br><a href=" https://odininspector.com/documentation"></a></p>
<h1 id="2-Terrain数据组织"><a href="#2-Terrain数据组织" class="headerlink" title="2.Terrain数据组织"></a>2.Terrain数据组织</h1><p>在Unity中有内置的Terrain系统，它是Unity官方提供的一套地形系统，可以直接在Inspector中刷地形。支持URP和HDRP，源码在C++层中，意味着个人开发者无法定制Terrain的细节。与Mesh的渲染不同，Terrain新开了一个Pass去处理，做了很多优化与适配。Terrain在移动端的性能表现并不好，在移动端制作地形依然偏向使用Mesh的方案，Mesh是适用性更广的工作流，突出一个思想简单，所以此处会使用Mesh实现地形。</p>
<figure>
    <img src="images/Chapter01/Unity_TerrainSystem.png" width="700" height="392" alt="image">
    <figcaption>图：使用Unity内置的Terrain系统</figcaption>
</figure>


<h2 id="2-1-地块分块处理"><a href="#2-1-地块分块处理" class="headerlink" title="2.1.地块分块处理"></a>2.1.地块分块处理</h2><h3 id="2-1-1-为什么要分块"><a href="#2-1-1-为什么要分块" class="headerlink" title="2.1.1.为什么要分块"></a>2.1.1.为什么要分块</h3><p>在大地图游戏中，对地图的分块处理是基操。在超大规模的地图离，通常将地图数据分为一个个Chunk，根据玩家的位置加载周围的Chunk。对地图分块，利于我们进行动态加载、剔除等操作，实现内存等方面的优化，更好管理地图数据。</p>
<p>以《艾尔登法环》为例，法环的地图总面积约为100平方千米，游戏中划分的最小网格单元为256m×256m，也会有更大一些的比如1024m×1024m的网格划分，这样可以对游戏内地图的总体网格数进行适当性的控制，同时保持远景的加载质量。 </p>
<figure>
    <img src="images/Chapter01/EldenRing_PPT.png" width="700" height="392" alt="image">
    <figcaption>图：《艾尔登法环》在2022年GDC中的汇报</figcaption>
</figure>
 
<p>而在策略游戏中，因为策略游戏一般是2.5D制作，地图往往是平面的，相比法环之类的大制作，在地图上考虑的东西要更少些，比如不需要考虑纵深结构。</p>
<p>我们在此简单地将地图块，划分成两层：世界地形会由多个Cluster组成，一个Cluster内置多个Tile，如下图所示：</p>
<figure>
    <img src="images/Chapter01/TerrainDivide_Model.png" width="700" height="392" alt="image">
    <figcaption>图：地形分块的简单模型</figcaption>
</figure>

<h3 id="2-1-2-地块分块模型"><a href="#2-1-2-地块分块模型" class="headerlink" title="2.1.2.地块分块模型"></a>2.1.2.地块分块模型</h3><p>在此简单阐述下地图模块中Terrain的分块模型：<br>-TerrainCluster：对应一个TIF文件，即一个现实中的地块<br>-TerrainTile：在Cluster的基础上进一步的划分，可以用于后续实现更细致的LOD切换</p>
<p>以下是两个地块单位的关键部分代码（注：以下关于LOD的字段可以先添加，后续建LOD的时候再使用）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TerrainCluster</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> idxX &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> idxY &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> longitude &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> latitude &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    Vector3Int terrainClusterSize;</span><br><span class="line">    <span class="built_in">int</span> tileSize;</span><br><span class="line">    TDList&lt;TerrainTile&gt; terrainTileList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TerrainTile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> tileIdxX &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> tileIdxY &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> longitude &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> latitude &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> curLODLevel &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    Vector3 clusterStartPoint;</span><br><span class="line">    <span class="built_in">int</span> tileSize;</span><br><span class="line">    <span class="built_in">int</span>[] LODLevels;</span><br><span class="line">    MeshData[] LODMeshes;</span><br><span class="line">    <span class="keyword">public</span> Vector3 tileCenterPos &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> MeshFilter meshFilter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-2-建立地块类"><a href="#2-2-建立地块类" class="headerlink" title="2.2.建立地块类"></a>2.2.建立地块类</h2><p>在完成上述的地块数据建模之后，我们可以开始构建地形Mesh了，下面代码用于建立TerrainCluster，缺失的字段直接补充即可</p>
<p>注：以下代码是较早的版本，查看最新版本代码请到：<br><a target="_blank" rel="noopener" href="https://github.com/huayuxingtguiyujing/WarGameMap"></a><br>注：建议直接跳过本节的TerrainCluster与TerrainTile构建，到下一节的地形Mesh构建</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitHeightCons</span>(<span class="params">Vector3Int terrainSize, Vector3Int clusterSize, <span class="built_in">int</span> tileSize, <span class="built_in">int</span> LODLevel, List&lt;HeightDataModel&gt; heightDataModels</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.terrainSize = terrainSize;</span><br><span class="line">    <span class="keyword">this</span>.clusterSize = clusterSize;</span><br><span class="line">    <span class="keyword">this</span>.tileSize = tileSize;</span><br><span class="line">    <span class="keyword">this</span>.LODLevel = LODLevel;</span><br><span class="line">    clusterWidth = terrainSize.x;</span><br><span class="line">    clusterHeight = terrainSize.z;</span><br><span class="line">    clusterList = <span class="keyword">new</span> TDList&lt;TerrainCluster&gt;(clusterWidth, clusterHeight);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;  i &lt; clusterHeight; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>;  j &lt; clusterWidth; j++) &#123;</span><br><span class="line">            GameObject clusterGo = CreateHeightCluster(i, j);</span><br><span class="line">            clusterList[i, j].InitTerrainCluster(……);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面的代码中，创建地形Mesh数据会分配大量内存，如果地形过大可能会炸，同时因为过程是同步的，如果创建的地块数量太多，会卡很久。所以这里建议使用懒初始化去构建地形，方法很简单，在需要这块地块的时候再创建地块的Mesh即可，此处暂时不记。</p>
<p>TerrainCluster中的InitTerrainCluster初始化方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitTerrainCluster</span>(<span class="params"><span class="built_in">int</span> idxX, <span class="built_in">int</span> idxY, <span class="built_in">int</span> longitude, <span class="built_in">int</span> latitude, Vector3Int terrainClusterSize, <span class="built_in">int</span> tileSize, <span class="built_in">int</span> LODLevel, GameObject clusterGo</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.idxX = idxX;</span><br><span class="line">    <span class="keyword">this</span>.idxY = idxY;</span><br><span class="line">    <span class="keyword">this</span>.longitude = longitude;</span><br><span class="line">    <span class="keyword">this</span>.latitude = latitude;</span><br><span class="line">    <span class="keyword">this</span>.terrainClusterSize = terrainClusterSize;</span><br><span class="line">    <span class="keyword">this</span>.tileSize = tileSize;</span><br><span class="line">    <span class="keyword">this</span>.LODLevel = LODLevel;</span><br><span class="line">    <span class="keyword">this</span>.clusterGo = clusterGo;</span><br><span class="line">    Vector3 startPoint = <span class="keyword">new</span> Vector3(terrainClusterSize.x * idxX, <span class="number">0</span>, terrainClusterSize.z * idxY);</span><br><span class="line">    InitTerrainCluster(startPoint);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitTerrainCluster</span>(<span class="params">Vector3 clusterStartPoint</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> tileNumPerLine = terrainClusterSize.x / tileSize;</span><br><span class="line">    terrainTileList = <span class="keyword">new</span> TDList&lt;TerrainTile&gt;(tileNumPerLine, tileNumPerLine);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tileNumPerLine; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; tileNumPerLine; j++) &#123;</span><br><span class="line">            MeshFilter meshFilter = CreateHeightTile(i, j);</span><br><span class="line">            terrainTileList[i, j].InitTileMeshData(i, j, longitude, latitude, clusterStartPoint, meshFilter,  lodLevels);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// generate mesh data </span></span><br><span class="line">        <span class="built_in">int</span> vertexNumFix = (<span class="built_in">int</span>)Mathf.Pow(<span class="number">2</span>, LODLevel );</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tileNumPerLine; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; tileNumPerLine; j++) &#123;</span><br><span class="line">                terrainTileList[i, j]. InitTerrainTile( tileSize, vertexNumFix, terrainClusterSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curLODLevel--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CreateHeightTile：用于创建一个游戏物体，代表一个Cluster，可以放置Mesh渲染组件，获取到MeshFilter作为Cluster的字段</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MeshFilter <span class="title">CreateHeightTile</span>(<span class="params"><span class="built_in">int</span> idxX, <span class="built_in">int</span> idxY</span>)</span> &#123;</span><br><span class="line">    GameObject tileGo = <span class="keyword">new</span> GameObject();</span><br><span class="line">    tileGo.transform.parent = clusterGo.transform;</span><br><span class="line">    tileGo.name = <span class="built_in">string</span>.Format(<span class="string">&quot;heightTile_&#123;0&#125;_&#123;1&#125;&quot;</span>, idxX, idxY);</span><br><span class="line">    MeshFilter meshFilter = tileGo.AddComponent&lt;MeshFilter&gt;();</span><br><span class="line">    tileGo.AddComponent&lt;MeshRenderer&gt;();</span><br><span class="line">    <span class="keyword">return</span> meshFilter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>TerrainTile中的InitTileMeshData初始化方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitTileMeshData</span>(<span class="params"><span class="built_in">int</span> idxX, <span class="built_in">int</span> idxY, <span class="built_in">int</span> longitude, <span class="built_in">int</span> latitude, Vector3 startPoint, MeshFilter meshFilter,<span class="built_in">int</span>[] lODLevels</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.clusterStartPoint = startPoint;</span><br><span class="line">    <span class="keyword">this</span>.meshFilter = meshFilter;</span><br><span class="line">    tileIdxX = idxX;</span><br><span class="line">    tileIdxY = idxY;</span><br><span class="line">    <span class="keyword">this</span>.longitude = longitude;</span><br><span class="line">    <span class="keyword">this</span>.latitude = latitude;</span><br><span class="line">    curLODLevel = <span class="number">-1</span>;       <span class="comment">// init as -1</span></span><br><span class="line">    LODLevels = lODLevels;</span><br><span class="line">    LODMeshes = <span class="keyword">new</span> MeshData[lODLevels.Length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-3-地形Mesh构建"><a href="#2-3-地形Mesh构建" class="headerlink" title="2.3.地形Mesh构建"></a>2.3.地形Mesh构建</h2><h3 id="2-3-1-MeshData数据类"><a href="#2-3-1-MeshData数据类" class="headerlink" title="2.3.1.MeshData数据类"></a>2.3.1.MeshData数据类</h3><p>最后是关键的构建Mesh的部分代码，我们为地形Tile专门写一个Mesh数据类，以下是它需要包含的字段</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MeshData</span> &#123;</span><br><span class="line">    Vector3[] vertexs = <span class="keyword">new</span> Vector3[<span class="number">1</span>];</span><br><span class="line">    Vector3[] fixedVertexs = <span class="keyword">new</span> Vector3[<span class="number">1</span>];			<span class="comment">// use to fix LOD seam</span></span><br><span class="line">    Vector3[] outofMeshVertexs = <span class="keyword">new</span> Vector3[<span class="number">1</span>];</span><br><span class="line">    Vector3[] fixedOutMeshVertexs = <span class="keyword">new</span> Vector3[<span class="number">1</span>];	<span class="comment">// use to fix LOD seam</span></span><br><span class="line">    <span class="built_in">int</span>[,] vertexIndiceMap = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">1</span>, <span class="number">1</span>];  <span class="comment">// map the (x, y) to index in vertexs/outofMeshVertexs</span></span><br><span class="line">    Vector3[] normals = <span class="keyword">new</span> Vector3[<span class="number">1</span>];</span><br><span class="line">    Vector2[] uvs = <span class="keyword">new</span> Vector2[<span class="number">1</span>];</span><br><span class="line">    Color[] colors = <span class="keyword">new</span> Color[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">int</span>[] triangles = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">int</span>[] outOfMeshTriangles = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>构建一个Mesh最基本的要素就是：<br>-Vertexs：顶点数组，最基本的要素<br>-Normals：法线数组，用于shader操作，实现正确的地图阴影和光照<br>-Uvs：纹理坐标，用于后续实现地形纹理在地形上的映射<br>-Colors：顶点颜色数组，如果shader不使用color的话可以不做设置，此处作为占位符</p>
<p>所以MeshData包含了上述字段，而值得注意的是这里使用了outofMeshVertexs数组来记录地形Mesh外的数据，这是因为每个地块边缘的顶点都需要额外地计算外面一层的片元，否则边缘顶点的法线计算会出现问题（因为只计算了本地块的三角型对法线的贡献），不同地块的的衔接处会出现明显的界限。</p>
<p>如下图所示，边缘虚线的顶点存储在outofMeshVertex中，不会用于构建Tile地块，也会存储额外的边缘三角型信息</p>
<figure>
    <img src="images/Chapter01/MoreVert_BuildMesh.png" width="700" height="392" alt="image">
    <figcaption>图：存储额外的顶点用于构建Mesh</figcaption>
</figure>

<h3 id="2-3-2-添加顶点"><a href="#2-3-2-添加顶点" class="headerlink" title="2.3.2.添加顶点"></a>2.3.2.添加顶点</h3><p>往MeshData中添加顶点和片元索引的方法。会根据一个外部的传入参数vertexIndex来决定要添加的顶点是Tile内的，还是在OutofMesh的，外部参数在后面的构建Mesh部分可见。三角型片元一样需要判断该片元是内部的还是外部的</p>
<p>此处参考了一个开源的游戏地形构建方案，可以结合此链接学习：<br><a href = "https://github.com/SebLague/Procedural-Landmass-Generation"></a></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddVertex</span>(<span class="params">Vector3 vertexPosition, Vector2 uv, <span class="built_in">int</span> vertIndex</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (vertIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        outofMeshVertexs[- vertIndex - <span class="number">1</span>] = vertexPosition;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vertexs[vertIndex] = vertexPosition;</span><br><span class="line">        uvs[vertIndex] = uv;</span><br><span class="line">        normals[vertIndex] = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        colors[vertIndex] = GetColorByHeight(vertexPosition.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddTriangle</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b, <span class="built_in">int</span> c, <span class="built_in">int</span> i = <span class="number">0</span>, <span class="built_in">int</span> j = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span> || c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (outOfMeshTriangleIndex + <span class="number">1</span> &gt; outOfMeshTriangles.Length - <span class="number">1</span>) &#123;</span><br><span class="line">            Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;triangle idx : &#123;0&#125;, &#123;1&#125; !&quot;</span>, i, j));</span><br><span class="line">            Debug.LogError(<span class="built_in">string</span>.Format(<span class="string">&quot;out of bound! cur idx : &#123;0&#125;, cur a : &#123;1&#125;, cur b : &#123;2&#125;, cur c : &#123;3&#125;, length : &#123;4&#125;&quot;</span>, outOfMeshTriangleIndex, a, b, c, outOfMeshTriangles.Length));</span><br><span class="line">        &#125;</span><br><span class="line">        outOfMeshTriangles[outOfMeshTriangleIndex] = a;</span><br><span class="line">        outOfMeshTriangles[outOfMeshTriangleIndex + <span class="number">1</span>] = b;</span><br><span class="line">        outOfMeshTriangles[outOfMeshTriangleIndex + <span class="number">2</span>] = c;</span><br><span class="line">        outOfMeshTriangleIndex += <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        triangles[triangleIndex] = a;</span><br><span class="line">        triangles[triangleIndex + <span class="number">1</span>] = b;</span><br><span class="line">        triangles[triangleIndex + <span class="number">2</span>] = c;</span><br><span class="line">        triangleIndex += <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-3-构建Mesh"><a href="#2-3-3-构建Mesh" class="headerlink" title="2.3.3.构建Mesh"></a>2.3.3.构建Mesh</h3><p>在Tile中构建Mesh逻辑如下，代码放置到TerrainTile中。根据传入的LOD级别（下一节会讲）、Tile的size，每个Tile地形一行应该有的Vertex数目，来共同构建一个TileMesh</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetMeshData</span>(<span class="params"><span class="built_in">int</span> curLODLevel, <span class="built_in">int</span> tileSize, <span class="built_in">int</span> vertexNumFix, Vector3Int terrainClusterSize</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.tileSize = tileSize;</span><br><span class="line">    <span class="comment">// caculate tile&#x27;s start point</span></span><br><span class="line">    <span class="built_in">float</span> startX = tileIdxX * tileSize;</span><br><span class="line">    <span class="built_in">float</span> startZ = tileIdxY * tileSize;</span><br><span class="line">    Vector3 startPoint = <span class="keyword">new</span> Vector3(startX, <span class="number">0</span>, startZ) + <span class="keyword">this</span>.clusterStartPoint;       <span class="comment">// </span></span><br><span class="line">tileCenterPos = startPoint + <span class="keyword">new</span> Vector3(tileSize / <span class="number">2</span>, <span class="number">0</span>, tileSize / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">int</span> gridNumPerLine = tileSize / vertexNumFix;</span><br><span class="line">    <span class="built_in">int</span> gridSize = tileSize / gridNumPerLine;</span><br><span class="line">    <span class="built_in">int</span> vertexPerLine = tileSize / vertexNumFix + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> gridNumPerLineFixed = gridNumPerLine + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int</span> vertexPerLineFixed = vertexPerLine + <span class="number">2</span>;</span><br><span class="line">    LODMeshes[curLODLevel] = <span class="keyword">new</span> MeshData();</span><br><span class="line">    MeshData meshData = LODMeshes[curLODLevel];</span><br><span class="line">    meshData.InitMeshData(gridNumPerLine, gridNumPerLineFixed, vertexPerLine, vertexPerLineFixed);</span><br><span class="line">    <span class="built_in">int</span> curInVertIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> curOutVertIdx = <span class="number">-1</span>;</span><br><span class="line">    Vector3 offsetInMeshVert = <span class="keyword">new</span> Vector3(gridSize, <span class="number">0</span>, gridSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; vertexPerLineFixed; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; vertexPerLineFixed; j++) &#123;</span><br><span class="line">            <span class="built_in">bool</span> isVertOutOfMesh = (i == <span class="number">0</span>) || (i == vertexPerLineFixed - <span class="number">1</span>) || (j == <span class="number">0</span>) || (j == vertexPerLineFixed - <span class="number">1</span>);</span><br><span class="line">            Vector3 vert = <span class="keyword">new</span> Vector3(gridSize * i, <span class="number">0</span>, gridSize * j) + startPoint - offsetInMeshVert;</span><br><span class="line">            <span class="comment">//float height = 0;</span></span><br><span class="line">            vert.y = height;</span><br><span class="line">            Vector2 uv = <span class="keyword">new</span> Vector2(vert.x / terrainClusterSize.x, vert.z / terrainClusterSize.z);</span><br><span class="line">            <span class="keyword">if</span> (isVertOutOfMesh) &#123;</span><br><span class="line">                meshData.AddVertex(vert, uv, curOutVertIdx);</span><br><span class="line">                meshData.SetIndiceInMap(i, j, curOutVertIdx);</span><br><span class="line">                <span class="comment">//vertexIndiceMap[i, j] = curOutVertIdx;</span></span><br><span class="line">                curOutVertIdx --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                meshData.AddVertex(vert, uv, curInVertIdx);</span><br><span class="line">                meshData.SetIndiceInMap(i, j, curInVertIdx);</span><br><span class="line">                <span class="comment">//vertexIndiceMap[i, j] = curInVertIdx;</span></span><br><span class="line">                curInVertIdx ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> curGridIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; gridNumPerLineFixed; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; gridNumPerLineFixed; j++) &#123;</span><br><span class="line">            <span class="comment">// i, j 是当前遍历到的 grid 的 index</span></span><br><span class="line">            <span class="built_in">int</span> cur_w = curGridIdx % gridNumPerLineFixed;</span><br><span class="line">            <span class="built_in">int</span> cur_h = curGridIdx / gridNumPerLineFixed;</span><br><span class="line">            <span class="built_in">int</span> next_w = cur_w + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> next_h = cur_h + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> a = meshData.GetIndiceInMap(cur_w, cur_h);</span><br><span class="line">            <span class="built_in">int</span> b = meshData.GetIndiceInMap(cur_w, next_h);</span><br><span class="line">            <span class="built_in">int</span> c = meshData.GetIndiceInMap(next_w, next_h);</span><br><span class="line">            <span class="built_in">int</span> d = meshData.GetIndiceInMap(next_w, cur_h);</span><br><span class="line">            meshData.AddTriangle(a, b, c, i, j);</span><br><span class="line">            meshData.AddTriangle(a, c, d, i, j);</span><br><span class="line">            curGridIdx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    meshData.RecaculateNormal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-4-计算法线"><a href="#2-3-4-计算法线" class="headerlink" title="2.3.4.计算法线"></a>2.3.4.计算法线</h3><p>先前一直在强调，要记录OutOfMesh即Tile地块外部的，这一操作就是为了正确地计算法线，计算法线的代码如下：<br>此处代码源自（伟大的作者！）：<br><a href = "https://github.com/SebLague/Procedural-Landmass-Generation/blob/master/Proc%20Gen%20E21/Assets/Scripts/MeshGenerator.cs"></a></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RecaculateNormal</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> triangleCount = triangles.Length / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; triangleCount; i++) &#123;</span><br><span class="line">        <span class="built_in">int</span> normalTriangleIndex = i * <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> vertexIndexA = triangles[normalTriangleIndex];</span><br><span class="line">        <span class="built_in">int</span> vertexIndexB = triangles[normalTriangleIndex + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">int</span> vertexIndexC = triangles[normalTriangleIndex + <span class="number">2</span>];</span><br><span class="line">        Vector3 triangleNormal = SurfaceNormalFromIndices(vertexIndexA, vertexIndexB, vertexIndexC);</span><br><span class="line">        <span class="comment">//Vector3 triangleNormal = SurfaceNormalFromIndices_Fixed(vertexIndexA, vertexIndexB, vertexIndexC);</span></span><br><span class="line">        normals[vertexIndexA] += triangleNormal;</span><br><span class="line">        normals[vertexIndexB] += triangleNormal;</span><br><span class="line">        normals[vertexIndexC] += triangleNormal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// border triangle, caculate their value to normal</span></span><br><span class="line">    <span class="built_in">int</span> borderTriangleCount = outOfMeshTriangles.Length / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; borderTriangleCount; i++) &#123;</span><br><span class="line">        <span class="built_in">int</span> normalTriangleIndex = i * <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> vertexIndexA = outOfMeshTriangles[normalTriangleIndex];</span><br><span class="line">        <span class="built_in">int</span> vertexIndexB = outOfMeshTriangles[normalTriangleIndex + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">int</span> vertexIndexC = outOfMeshTriangles[normalTriangleIndex + <span class="number">2</span>];</span><br><span class="line">        Vector3 triangleNormal = SurfaceNormalFromIndices(vertexIndexA, vertexIndexB, vertexIndexC);</span><br><span class="line">        <span class="comment">//Vector3 triangleNormal = SurfaceNormalFromIndices_Fixed(vertexIndexA, vertexIndexB, vertexIndexC);</span></span><br><span class="line">        <span class="keyword">if</span> (vertexIndexA &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            normals[vertexIndexA] += triangleNormal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vertexIndexB &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            normals[vertexIndexB] += triangleNormal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vertexIndexC &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            normals[vertexIndexC] += triangleNormal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; normals.Length; i++) &#123;</span><br><span class="line">        normals[i].Normalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在联通了TerrainCluster与TerrainTile的执行逻辑后，通过odin编辑器或者其他途径生成每个Tile的Mesh，此处的编辑器代码暂不提供，因为关键的逻辑已经写完，如何调用这些方法都是次要的了； </p>
<p>此时我们已经构建了一个基础地形，如果上述步骤全部通过，它在scene中会是这样的平面：</p>
<figure>
    <img src="images/Chapter01/Terrain_Result.png" width="700" height="392" alt="image">
    <figcaption>图：生成的地形Mesh</figcaption>
</figure>

<p>还远远不够！</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>

  









    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2025 Nobody
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>