<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>策略游戏地图制作-五-地形减面-上 | 只羊的博客 | 记录游戏开发历程</title>

  
  <meta name="author" content="huayuxingtguiyujing">
  

  
  <meta name="description" content="1.地形减面在我们之前的地形制作中采用平铺方案制作地形Mesh，但Terrain平铺在大部分情况下是很浪费的，例如在平原这种不需要多少顶点表达的区域，或者其他坡度低、斜率低、变化小的地带。加上如果要支持超大规模的地图，还需要做很多优化，所以应当做进一步的减面处理。
下面使用经典的QEM算法对Terrain进行减面操作，写这个的过程也算是在做减面插件，只不过地形的减面需要注意不同地块之间的接缝，避免连接出问题。下面是本节结束后的减面效果演示：

    
    图：地形Mesh减面前后对比



1.1.已有的地形减面方案以下列举一些已有的减面工具，以供参考">
  

  
  
  <meta name="keywords" content="">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="策略游戏地图制作-五-地形减面-上"/>

  <meta property="og:site_name" content="只羊的博客"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="只羊的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">只羊的博客</a>
    </h1>
    <p class="site-description">记录游戏开发历程</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/links">链接</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>策略游戏地图制作-五-地形减面-上</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2025/03/09/策略游戏地图制作-五-地形减面-上/" rel="bookmark">
        <time class="entry-date published" datetime="2025-03-09T09:47:22.000Z">
          2025-03-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="1-地形减面"><a href="#1-地形减面" class="headerlink" title="1.地形减面"></a>1.地形减面</h1><p>在我们之前的地形制作中采用平铺方案制作地形Mesh，但Terrain平铺在大部分情况下是很浪费的，例如在平原这种不需要多少顶点表达的区域，或者其他坡度低、斜率低、变化小的地带。加上如果要支持超大规模的地图，还需要做很多优化，所以应当做进一步的减面处理。</p>
<p>下面使用经典的QEM算法对Terrain进行减面操作，写这个的过程也算是在做减面插件，只不过地形的减面需要注意不同地块之间的接缝，避免连接出问题。下面是本节结束后的减面效果演示：</p>
<figure>
    <img src="/images/Chapter05/MeshReduce_Result.png" width="550" height="450" alt="image">
    <figcaption>图：地形Mesh减面前后对比</figcaption>
</figure>


<h2 id="1-1-已有的地形减面方案"><a href="#1-1-已有的地形减面方案" class="headerlink" title="1.1.已有的地形减面方案"></a>1.1.已有的地形减面方案</h2><p>以下列举一些已有的减面工具，以供参考</p>
<span id="more"></span>

<p>-Simplygon：多平台多语言支持的工业级减面插件，广泛应用于各种游戏中，有各种丰富的特性效果，功能十分强大。能给30天的免费试用，曾对个人开发者免费，可惜现在收费了<br>官网：<a href = "https://www.simplygon.com/" target="_blank">https://www.simplygon.com/</a></p>
<figure>
    <img src="/images/Chapter05/Simplygon_Result.png" width="550" height="450" alt="image">
    <figcaption>图：Simplygon插件效果（官网演示）</figcaption>
</figure>


<p>-UnityMeshSimplify：git上的轻量级开源项目，值得参考学习<br>源码：<a href = "https://github.com/ecidevilin/UnityMeshSimplify/tree/master" target="_blank">https://github.com/ecidevilin/UnityMeshSimplify/tree/master</a></p>
<p>-AutoLOD：unity官方推出的减面工具<br>源码：<a href = "https://github.com/Unity-Technologies/AutoLOD" target="_blank">https://github.com/Unity-Technologies/AutoLOD</a></p>
<p>-UE Nanite的cluster based的方案，非常经典，不必多说<br>官网文档：<a href = "https://dev.epicgames.com/documentation/zh-cn/unreal-engine/using-nanite-with-landscapes-in-unreal-engine" target="_blank">https://dev.epicgames.com/documentation/zh-cn/unreal-engine/using-nanite-with-landscapes-in-unreal-engine</a></p>
<h2 id="1-2-减面算法步骤"><a href="#1-2-减面算法步骤" class="headerlink" title="1.2.减面算法步骤"></a>1.2.减面算法步骤</h2><p>QuadricMeshReduction 是UE4使用的一种模型网格简化算法，能在尽量保持原模型拓扑结构的同时减少多边形数量。基本原理是通过计算每个顶点的 Quadric Error Metrics（误差矩阵）来评估顶点的简化程度，以此判断是否简化掉该顶点</p>
<p>该算法主要基于对顶点对的收缩，如图所示，v1，v2是一个vertex pair，消除v1，v2得到新顶点v-，为了确定怎么收缩，需要定义收缩的代价和收缩后新顶点的位置。</p>
<figure>
    <img src="/images/Chapter05/VertPair_Shrink.png" width="300" height="300" alt="image">
    <figcaption>图：顶点对的收缩</figcaption>
</figure>

<p>算法原论文链接：<br><a href = "https://dl.acm.org/doi/pdf/10.1145/258734.258849" target="_blank">Surface simplification using quadric error metrics</a></p>
<p>收缩代价即误差矩阵（Quadric Error Metric ），它是为目标Mesh中的每个顶点计算的4x4矩阵，记录顶点位置的几何特征以及它和周围面的误差度量，以此我们可以得知简化该顶点后对整体模型的代价。以下是计算步骤：</p>
<p>（1）.定义Δ为一个顶点（即v&#x3D;[vx, vy, vz, 1]T）到所有相邻面的距离之和</p>
<figure>
    <img src="/images/Chapter05/Caculate_Distance.png" width="300" height="200" alt="image">
</figure>

<p>展开后可以得到：</p>
<figure>
    <img src="/images/Chapter05/Caculate_Distance02.png" width="250" height="250" alt="image">
</figure>

<p>其中Kp是到该顶点相邻平面ax + by + cz + d &#x3D; 0的距离，可以理解为每个面的误差矩阵Qi，计算公式如下：</p>
<figure>
    <img src="/images/Chapter05/Plane_Q01.png" width="300" height="200" alt="image">
</figure>

<p>（2）.依据上述公式我们可以为每个平面计算它的误差矩阵，得到的和即为每个顶点的误差矩阵：</p>
<figure>
    <img src="/images/Chapter05/Plane_Q02.png" width="200" height="200" alt="image">
</figure>

<p>（3）.对于每个顶点对（v1，v2），它们的误差矩阵为：</p>
<figure>
    <img src="/images/Chapter05/Plane_Q03.png" width="200" height="200" alt="image">
</figure>

<p>（4）.计算新顶点的位置可以采取简单的取平均值办法即v&#x3D;(v1+v2)&#x2F;2，但也可以取最优点，通过：</p>
<figure>
    <img src="/images/Chapter05/Plane_Q04.png" width="300" height="200" alt="image">
</figure>

<p>可以确定新顶点，将等式联立展开后可以得到：</p>
<figure>
    <img src="/images/Chapter05/Plane_Q05.png" width="300" height="200" alt="image">
    <img src="/images/Chapter05/Plane_Q06.png" width="300" height="200" alt="image">
</figure>
 
<p>解方程即可</p>
<p>减面的步骤中，我们需要维护一个最小堆，该最小堆存放所有待简化的顶点对，每次选择具有最小误差代价的顶点对进行合并。</p>
<p>合并操作会把两个顶点变成一个新顶点，并更新相关点的顶点对关系和三角型索引关系（这个过程中最小堆里的顶点对也要重新更新），以及相关面的法线和边界，确保网格合法。</p>
<p>重复上述取出顶点对优化的过程，直到满足预定的简化目标，如减少到指定的顶点数或面数。</p>
<p>最后需要一提，对于地形减面来说，因为对于每个地块的减面操作都是独立的，用以上算法得到的简化模型拼接在一起很容易产生缝隙。对此，我们只需要保持地块的最外层顶点不变即可，实现起来可以传入一个List<int>表示不可修改的顶点索引，在建立顶点对的时候跳过包含边缘顶点的顶点对</p>
<figure>
    <img src="/images/Chapter05/Ensure_Edge_Vert.png" width="550" height="470" alt="image">
    <figcaption>图：地块边缘顶点在简化过程中不会修改</figcaption>
</figure>



<h2 id="1-3-减面算法实现"><a href="#1-3-减面算法实现" class="headerlink" title="1.3.减面算法实现"></a>1.3.减面算法实现</h2><p>本节代码可以参考：</p>
<p><a href = "https://github.com/huayuxingtguiyujing/WarGameMap/blob/main/Runtime/Controller/Terrain/TerrainSimplifyer.cs" target="_blank">WarGameMap&#x2F;blob&#x2F;main&#x2F;Runtime&#x2F;Controller&#x2F;Terrain&#x2F;TerrainSimplifyer.cs</a></p>
<h3 id="（1）-建立最小堆结构和顶点对结构"><a href="#（1）-建立最小堆结构和顶点对结构" class="headerlink" title="（1）.建立最小堆结构和顶点对结构"></a>（1）.建立最小堆结构和顶点对结构</h3><p>在上面的算法步骤中，我们可以确定最小堆是需要定制的，因为每次处理顶点对后会引发其他相关顶点对的更新。除此之外，为方面维护和计算，我们还可以为顶点对建立数据类：</p>
<p>顶点对数据类实现：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">VectorPair</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> v1Idx &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> v2Idx &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Vector3 v1 &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Vector3 v2 &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Matrix4x4 Q1 &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Matrix4x4 Q2 &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Error &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; <span class="comment">// 存储合并的误差值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsValid &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VectorPair</span>(<span class="params"><span class="built_in">int</span> idx1, <span class="built_in">int</span> idx2, Vector3 v1, Vector3 v2, Matrix4x4 q1, Matrix4x4 q2</span>)</span> &#123;</span><br><span class="line">        v1Idx = idx1;</span><br><span class="line">        v2Idx = idx2;</span><br><span class="line">        <span class="keyword">this</span>.v1 = v1;</span><br><span class="line">        <span class="keyword">this</span>.v2 = v2;</span><br><span class="line">        Q1 = q1;</span><br><span class="line">        Q2 = q2;</span><br><span class="line">        Error = ComputePairError(); <span class="comment">// 计算误差</span></span><br><span class="line">        IsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ContainsVert</span>(<span class="params"><span class="built_in">int</span> idx</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> idx == v1Idx || idx == v2Idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdatePair</span>(<span class="params"><span class="built_in">int</span> oldIdx, <span class="built_in">int</span> newIdx, Vector3 newV, Matrix4x4 newQ</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1Idx == v2Idx) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((v1Idx == oldIdx &amp;&amp; v2Idx == newIdx) || (v2Idx == oldIdx &amp;&amp; v1Idx == newIdx) &amp;&amp; (oldIdx != newIdx)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (oldIdx == v1Idx) &#123;</span><br><span class="line">            v1Idx = newIdx;</span><br><span class="line">            v1 = newV;</span><br><span class="line">            Q1 = newQ;</span><br><span class="line">            Error = ComputePairError();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(oldIdx == v2Idx) &#123;</span><br><span class="line">            v2Idx = newIdx;</span><br><span class="line">            v2 = newV;</span><br><span class="line">            Q2 = newQ;</span><br><span class="line">            Error = ComputePairError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">ComputePairError</span>()</span> &#123;</span><br><span class="line">        Vector3 vOptimal = GetMergedPosition();</span><br><span class="line">        Vector4 vH = <span class="keyword">new</span> Vector4(vOptimal.x, vOptimal.y, vOptimal.z, <span class="number">1</span>);</span><br><span class="line">        Matrix4x4 Q = SimplifyHelper.AddMatrices(Q1, Q2);</span><br><span class="line">        <span class="keyword">return</span> Vector4.Dot(vH, Q * vH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector3 <span class="title">GetMergedPosition_Optimal</span>()</span> &#123;</span><br><span class="line">        Matrix4x4 Q = SimplifyHelper.AddMatrices(Q1, Q2);</span><br><span class="line"></span><br><span class="line">        Matrix4x4 A = <span class="keyword">new</span> Matrix4x4();</span><br><span class="line">        A.SetRow(<span class="number">0</span>, <span class="keyword">new</span> Vector4(Q.m00, Q.m01, Q.m02, <span class="number">0</span>));</span><br><span class="line">        A.SetRow(<span class="number">1</span>, <span class="keyword">new</span> Vector4(Q.m10, Q.m11, Q.m12, <span class="number">0</span>));</span><br><span class="line">        A.SetRow(<span class="number">2</span>, <span class="keyword">new</span> Vector4(Q.m20, Q.m21, Q.m22, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        Vector3 b = <span class="keyword">new</span> Vector3(-Q.m03, -Q.m13, -Q.m23);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求 A 的行列式，判断是否可逆</span></span><br><span class="line">        <span class="built_in">float</span> det = A.determinant;</span><br><span class="line">        <span class="keyword">if</span> (Mathf.Abs(det) &gt; <span class="number">1e-6</span>f) &#123;</span><br><span class="line">            Matrix4x4 A_inv = A.inverse;</span><br><span class="line">            <span class="keyword">return</span> A_inv.MultiplyPoint3x4(b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (v1 + v2) * <span class="number">0.5f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">is</span> VectorPair other) &#123;</span><br><span class="line">            <span class="keyword">return</span> (v1Idx == other.v1Idx &amp;&amp; v2Idx == other.v2Idx) || (v1Idx == other.v2Idx &amp;&amp; v2Idx == other.v1Idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v1Idx.GetHashCode() ^ v2Idx.GetHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最小堆实现：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">QEMMinHeap</span> &#123;</span><br><span class="line">        </span><br><span class="line">    List&lt;VectorPair&gt; heap = <span class="keyword">new</span> List&lt;VectorPair&gt;();</span><br><span class="line">    Dictionary&lt;VectorPair, <span class="built_in">int</span>&gt; heap_idx_dict = <span class="keyword">new</span> Dictionary&lt;VectorPair, <span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Count =&gt; heap.Count;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">Parent</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">LeftChild</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">RightChild</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params">VectorPair pair</span>)</span> &#123;</span><br><span class="line">        heap.Add(pair);</span><br><span class="line">        heap_idx_dict.Add(pair, <span class="number">-1</span>);</span><br><span class="line">        HeapifyUp(heap.Count - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> VectorPair <span class="title">GetTop</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.Count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        VectorPair min = heap[<span class="number">0</span>];</span><br><span class="line">        heap[<span class="number">0</span>] = heap[heap.Count - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        heap_idx_dict.Remove(min);</span><br><span class="line">        heap_idx_dict[heap[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        heap.RemoveAt(heap.Count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        HeapifyDown(<span class="number">0</span>);</span><br><span class="line">        min.IsValid = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdatePair</span>(<span class="params">VectorPair pair</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// TODO：目前这一步似乎有问题，需要修复</span></span><br><span class="line">        <span class="keyword">if</span> (!heap_idx_dict.ContainsKey(pair)) &#123;</span><br><span class="line">            Debug.LogError(<span class="string">$&quot;pair 未找到: <span class="subst">&#123;pair.v1Idx&#125;</span>, <span class="subst">&#123;pair.v2Idx&#125;</span>&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> idx = heap_idx_dict[pair];</span><br><span class="line">        heap[idx] = pair; <span class="comment">// ？？？</span></span><br><span class="line">        HeapifyUp(idx);</span><br><span class="line">        HeapifyDown(idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HeapifyUp</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; heap[i].Error &lt; heap[Parent(i)].Error) &#123;</span><br><span class="line">            Swap(i, Parent(i));</span><br><span class="line">            i = Parent(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HeapifyDown</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> smallest = i;</span><br><span class="line">        <span class="built_in">int</span> left = LeftChild(i);</span><br><span class="line">        <span class="built_in">int</span> right = RightChild(i);</span><br><span class="line">        <span class="keyword">if</span> (left &lt; heap.Count &amp;&amp; heap[left].Error &lt; heap[smallest].Error)</span><br><span class="line">            smallest = left;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; heap.Count &amp;&amp; heap[right].Error &lt; heap[smallest].Error)</span><br><span class="line">            smallest = right;</span><br><span class="line">        <span class="keyword">if</span> (smallest != i) &#123;</span><br><span class="line">            Swap(i, smallest);</span><br><span class="line">            HeapifyDown(smallest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">int</span> j</span>)</span> &#123;</span><br><span class="line">        heap_idx_dict[heap[i]] = j;</span><br><span class="line">        heap_idx_dict[heap[j]] = i;</span><br><span class="line">        (heap[i], heap[j]) = (heap[j], heap[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）-对传入的Mesh数据进行处理"><a href="#（2）-对传入的Mesh数据进行处理" class="headerlink" title="（2）.对传入的Mesh数据进行处理"></a>（2）.对传入的Mesh数据进行处理</h3><p>先不考虑normal和uv的计算，仅考虑传入的vertex和triangle，对于传入的Mesh数据：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3[] vertexs;</span><br><span class="line"><span class="built_in">int</span>[] triangles;</span><br></pre></td></tr></table></figure>

<p>建立如下数据结构：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span>[] vertex_valid;								<span class="comment">// 顶点是否被去除</span></span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, List&lt;<span class="built_in">int</span>&gt;&gt; vertex_link_triangle_dict;	<span class="comment">// 顶点相关的所有三角型</span></span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, Matrix4x4&gt; vertex_Q_dict;			<span class="comment">// 每个顶点对应的Q矩阵</span></span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, List&lt;VectorPair&gt;&gt; vertex_pair_dict;	<span class="comment">// 每个顶点以及其相连的顶点对</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span>[] triangle_valid;							<span class="comment">// 三角形是否被去除</span></span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, List&lt;<span class="built_in">int</span>&gt;&gt; triangle_contains_vert_dict;<span class="comment">// 每个三角型包含的顶点索引</span></span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, Matrix4x4&gt; triangle_Q_dict;			<span class="comment">// 每个三角型平面对应的Q矩阵</span></span><br><span class="line"></span><br><span class="line">QEMMinHeap qemMinHeap;</span><br><span class="line">HashSet&lt;<span class="built_in">int</span>&gt; edgeVertMap;   			<span class="comment">// 判断顶点是否是边缘顶点（不可被去除）</span></span><br><span class="line">HashSet&lt;<span class="built_in">string</span>&gt; hasAddThisPairMap;     <span class="comment">// 判断顶点对是否已经被加入</span></span><br></pre></td></tr></table></figure>

<p>初始化上述数据的代码，传入Mesh，边缘顶点数据EdgeVertexs，EdgeVertexNormals，要优化到的顶点比例 simplifyTarget，例传入0.6，表示最终要优化到仅剩下60%顶点：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitSimplifyer</span>(<span class="params">Mesh mesh, List&lt;<span class="built_in">int</span>&gt; edgeVerts, List&lt;Vector3&gt; edgeNormals, <span class="built_in">float</span> simplifyTarget</span>)</span> &#123;</span><br><span class="line">    meshName = mesh.name;</span><br><span class="line">    vertexs = mesh.vertices;</span><br><span class="line">    triangles = mesh.triangles;</span><br><span class="line"></span><br><span class="line">    vertCnt = vertexs.Length;</span><br><span class="line">    targetCnt = (<span class="built_in">int</span>)(vertexs.Length * simplifyTarget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init vertex&#x27;s data</span></span><br><span class="line">    <span class="built_in">int</span> vertNum = vertexs.Length;</span><br><span class="line">    vertex_valid = <span class="keyword">new</span> <span class="built_in">bool</span>[vertNum];</span><br><span class="line">    Array.Fill(vertex_valid, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init vert links to triangle......</span></span><br><span class="line">    vertex_link_triangle_dict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, List&lt;<span class="built_in">int</span>&gt;&gt;(vertNum);</span><br><span class="line">    vertex_Q_dict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, Matrix4x4&gt;(vertNum);</span><br><span class="line">    vertex_pair_dict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, List&lt;VectorPair&gt;&gt;(vertNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; vertNum; i++) &#123;</span><br><span class="line">        vertex_link_triangle_dict[i] = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        vertex_pair_dict[i] = <span class="keyword">new</span> List&lt;VectorPair&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct triangle&#x27;s data</span></span><br><span class="line">    <span class="built_in">int</span> triIdxNum = triangles.Length;</span><br><span class="line">    <span class="keyword">if</span>(triIdxNum % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;error! not valid triangle num : <span class="subst">&#123;triIdxNum&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> triNum = triIdxNum / <span class="number">3</span>;</span><br><span class="line">    triangle_valid = <span class="keyword">new</span> <span class="built_in">bool</span>[triNum];</span><br><span class="line">    Array.Fill(triangle_valid, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init triangle to vert dict</span></span><br><span class="line">    triangle_contains_vert_dict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, List&lt;<span class="built_in">int</span>&gt;&gt;(triNum);</span><br><span class="line">    triangle_Q_dict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, Matrix4x4&gt;(triNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="built_in">int</span> triIdx = <span class="number">0</span>; triIdx &lt; triNum; triIdx++ ) &#123;</span><br><span class="line">        <span class="built_in">int</span> tri_vert_start = triIdx * <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> v1 = triangles[tri_vert_start];</span><br><span class="line">        <span class="built_in">int</span> v2 = triangles[tri_vert_start + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">int</span> v3 = triangles[tri_vert_start + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        triangle_contains_vert_dict[triIdx] = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; v1, v2, v3 &#125;;</span><br><span class="line"></span><br><span class="line">        vertex_link_triangle_dict[v1].Add(triIdx);</span><br><span class="line">        vertex_link_triangle_dict[v2].Add(triIdx);</span><br><span class="line">        vertex_link_triangle_dict[v3].Add(triIdx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set triangle&#x27;s Q</span></span><br><span class="line">        Vector4 triPlane = SimplifyHelper.GetPlaneEquation(vertexs[v1], vertexs[v2], vertexs[v3]);</span><br><span class="line">        triangle_Q_dict[triIdx] = SimplifyHelper.CaculateKpForPlane(triPlane);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init vert Idx to Q dict</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; vertNum; i++) &#123;</span><br><span class="line">        List&lt;<span class="built_in">int</span>&gt; vert_tri_idxs = vertex_link_triangle_dict[i];</span><br><span class="line">        Matrix4x4 res = Matrix4x4.zero;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> triIdx <span class="keyword">in</span> vert_tri_idxs)</span><br><span class="line">        &#123;</span><br><span class="line">            res = SimplifyHelper.AddMatrices(res, triangle_Q_dict[triIdx]);</span><br><span class="line">        &#125;</span><br><span class="line">        vertex_Q_dict[i] = res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set edge vert&#x27;s message</span></span><br><span class="line">    edgeVertMap = <span class="keyword">new</span> HashSet&lt;<span class="built_in">int</span>&gt;(edgeVerts.Count);</span><br><span class="line">    edgeVert_normals_dict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, Vector3&gt;(edgeVerts.Count);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; edgeVerts.Count; i++) &#123;</span><br><span class="line">        edgeVertMap.Add(edgeVerts[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init vert pair, add them to heap;</span></span><br><span class="line">    qemMinHeap = <span class="keyword">new</span> QEMMinHeap();</span><br><span class="line">    hasAddThisPairMap = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> triIdx = <span class="number">0</span>; triIdx &lt; triNum; triIdx++) &#123;</span><br><span class="line">        <span class="built_in">int</span> tri_vert_start = triIdx * <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> v1 = triangles[tri_vert_start];</span><br><span class="line">        <span class="built_in">int</span> v2 = triangles[tri_vert_start + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">int</span> v3 = triangles[tri_vert_start + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> canDelV1 = !edgeVertMap.Contains(v1);</span><br><span class="line">        <span class="built_in">bool</span> canDelV2 = !edgeVertMap.Contains(v2);</span><br><span class="line">        <span class="built_in">bool</span> canDelV3 = !edgeVertMap.Contains(v3);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (canDelV1 &amp;&amp; canDelV2 &amp;&amp;  !HasAddThisPair(v1, v2)) &#123;</span><br><span class="line">            <span class="comment">//建立顶点对，然后加入到最小堆中</span></span><br><span class="line">            VectorPair vectorPair = <span class="keyword">new</span> VectorPair(v1, v2, vertexs[v1], vertexs[v2], vertex_Q_dict[v1], vertex_Q_dict[v2]);</span><br><span class="line">            qemMinHeap.Insert(vectorPair);</span><br><span class="line">            vertex_pair_dict[v1].Add(vectorPair);</span><br><span class="line">            vertex_pair_dict[v2].Add(vectorPair);</span><br><span class="line">            SetPairAdded(v1, v2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (canDelV2 &amp;&amp; canDelV3 &amp;&amp; !HasAddThisPair(v2, v3)) &#123;</span><br><span class="line">            VectorPair vectorPair = <span class="keyword">new</span> VectorPair(v2, v3, vertexs[v2], vertexs[v3], vertex_Q_dict[v2], vertex_Q_dict[v3]);</span><br><span class="line">            qemMinHeap.Insert(vectorPair);</span><br><span class="line">            vertex_pair_dict[v2].Add(vectorPair);</span><br><span class="line">            vertex_pair_dict[v3].Add(vectorPair);</span><br><span class="line">            SetPairAdded(v2, v3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (canDelV1 &amp;&amp; canDelV3 &amp;&amp; !HasAddThisPair(v1, v3)) &#123;</span><br><span class="line">            VectorPair vectorPair = <span class="keyword">new</span> VectorPair(v1, v3, vertexs[v1], vertexs[v3], vertex_Q_dict[v1], vertex_Q_dict[v3]);</span><br><span class="line">            qemMinHeap.Insert(vectorPair);</span><br><span class="line">            vertex_pair_dict[v1].Add(vectorPair);</span><br><span class="line">            vertex_pair_dict[v3].Add(vectorPair);</span><br><span class="line">            SetPairAdded(v1, v3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">HasAddThisPair</span>(<span class="params"><span class="built_in">int</span> v1, <span class="built_in">int</span> v2</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> pair_id1 = <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;_&#123;1&#125;&quot;</span>, v1, v2);</span><br><span class="line">    <span class="built_in">string</span> pair_id2 = <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;_&#123;1&#125;&quot;</span>, v2, v1);</span><br><span class="line">    <span class="keyword">if</span> (hasAddThisPairMap.Contains(pair_id1) || hasAddThisPairMap.Contains(pair_id2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetPairAdded</span>(<span class="params"><span class="built_in">int</span> v1, <span class="built_in">int</span> v2</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> pair_id1 = <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;_&#123;1&#125;&quot;</span>, v1, v2);</span><br><span class="line">    <span class="built_in">string</span> pair_id2 = <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;_&#123;1&#125;&quot;</span>, v2, v1);</span><br><span class="line">    hasAddThisPairMap.Add(pair_id1);</span><br><span class="line">    hasAddThisPairMap.Add(pair_id2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）-执行减面操作"><a href="#（3）-执行减面操作" class="headerlink" title="（3）.执行减面操作"></a>（3）.执行减面操作</h3><p>减面过程上面已经叙述，每次取出Q最小的顶点对然后删除，然后刷新顶点相关的数据。中间的一些步骤很容易踩坑，特别是更新顶点对相关数据时：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartSimplify</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> curCnt = vertCnt;</span><br><span class="line">    <span class="built_in">int</span> iterCnt = <span class="number">0</span>;    <span class="comment">// 防止无限循环</span></span><br><span class="line">    <span class="built_in">int</span> maxIter = vertCnt - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(curCnt &gt; targetCnt &amp;&amp; iterCnt &lt; maxIter) &#123;</span><br><span class="line"></span><br><span class="line">        VectorPair pair = qemMinHeap.GetTop();</span><br><span class="line"></span><br><span class="line">        Vector3 newV = pair.GetMergedPosition();</span><br><span class="line">        Matrix4x4 newM = SimplifyHelper.AddMatrices(pair.Q1, pair.Q2);</span><br><span class="line">        <span class="built_in">int</span> idx1 = pair.v1Idx;</span><br><span class="line">        <span class="built_in">int</span> idx2 = pair.v2Idx;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!vertex_valid[idx1]) &#123;</span><br><span class="line">            <span class="comment">//Debug.LogError($&quot;vert &#123;idx1&#125; is not valid， 本次 iter cnt ：&#123;iterCnt&#125;&quot;);</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!vertex_valid[idx2]) &#123;</span><br><span class="line">            <span class="comment">//Debug.LogError($&quot;vert &#123;idx2&#125; is not valid， 本次 iter cnt ：&#123;iterCnt&#125;&quot;);</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// keep v1, use v1 to storage new V, erase v2</span></span><br><span class="line">        vertexs[idx1] = newV;</span><br><span class="line">        vertex_valid[idx2] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update all pair that link to idx2, idx1</span></span><br><span class="line">        <span class="built_in">int</span> length2 = vertex_pair_dict[idx2].Count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = length2 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">var</span> idx2_pair = vertex_pair_dict[idx2][i];</span><br><span class="line">            <span class="keyword">if</span> (pair.Equals(idx2_pair) || pair == idx2_pair) &#123;</span><br><span class="line">                vertex_pair_dict[idx2].RemoveAt(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            idx2_pair.UpdatePair(idx2, idx1, newV, newM);</span><br><span class="line">            <span class="comment">//qemMinHeap.UpdatePair(idx2_pair);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> length1 = vertex_pair_dict[idx1].Count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = length1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">var</span> idx1_pair = vertex_pair_dict[idx1][i];</span><br><span class="line">            <span class="keyword">if</span> (pair.Equals(idx1_pair) || pair == idx1_pair) &#123;</span><br><span class="line">                vertex_pair_dict[idx1].RemoveAt(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            idx1_pair.UpdatePair(idx1, idx1, newV, newM);</span><br><span class="line">            <span class="comment">//qemMinHeap.UpdatePair(idx1_pair);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add all v2&#x27;s vertex pair to v1</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> idx2_pair <span class="keyword">in</span> vertex_pair_dict[idx2]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx2_pair.v1Idx != idx1 &amp;&amp; idx2_pair.v2Idx != idx1) &#123;</span><br><span class="line">                Debug.LogError(<span class="string">$&quot;不应该出现的情况，idx1 没有设置正确 * 2 ：<span class="subst">&#123;idx2_pair.v1Idx&#125;</span>,<span class="subst">&#123;idx2_pair.v2Idx&#125;</span>,<span class="subst">&#123;idx1&#125;</span>,<span class="subst">&#123;idx2&#125;</span>,iterCnt: <span class="subst">&#123;iterCnt&#125;</span>&quot;</span>);</span><br><span class="line">                <span class="comment">//continue;</span></span><br><span class="line">            &#125;</span><br><span class="line">            vertex_pair_dict[idx1].Add(idx2_pair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update all triangle that link to idx2, replace them to idx1</span></span><br><span class="line">        <span class="built_in">int</span> commonTriCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> triIdx <span class="keyword">in</span> vertex_link_triangle_dict[idx2]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!triangle_valid[triIdx]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (IsCommonTriangle(idx1, idx2, triIdx)) &#123;</span><br><span class="line">                triangle_valid[triIdx] = <span class="literal">false</span>;</span><br><span class="line">                commonTriCnt++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UpdateTriangleVert(idx2, idx1, triIdx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把 idx2 的所有相邻三角形，移交给 idx1 顶点</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> triIdx <span class="keyword">in</span> vertex_link_triangle_dict[idx2]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!triangle_valid[triIdx]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!vertex_link_triangle_dict[idx1].Contains(triIdx)) &#123;</span><br><span class="line">                vertex_link_triangle_dict[idx1].Add(triIdx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curCnt--;</span><br><span class="line"></span><br><span class="line">        iterCnt++;</span><br><span class="line">        <span class="keyword">if</span> (iterCnt &gt;= maxIter) &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;simplify end because iterCnt has reach its limit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">IsCommonTriangle</span>(<span class="params"><span class="built_in">int</span> idx1, <span class="built_in">int</span> idx2, <span class="built_in">int</span> triIdx</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// triangle that use this pair as common egde, set them not valid</span></span><br><span class="line">    <span class="built_in">int</span> tri_vert_start = triIdx * <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">int</span> tri_v1 = triangles[tri_vert_start];</span><br><span class="line">    <span class="built_in">int</span> tri_v2 = triangles[tri_vert_start + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">int</span> tri_v3 = triangles[tri_vert_start + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> exist_idx1 = tri_v1 == idx1 || tri_v2 == idx1 || tri_v3 == idx1;</span><br><span class="line">    <span class="built_in">bool</span> exist_idx2 = tri_v1 == idx2 || tri_v2 == idx2 || tri_v3 == idx2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tri_v1 == idx1 &amp;&amp; tri_v1 == idx2) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tri_v2 == idx1 &amp;&amp; tri_v2 == idx2) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tri_v3 == idx1 &amp;&amp; tri_v3 == idx2) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        Debug.LogError(<span class="string">$&quot;不应该出现的情况！计算共边三角型时发现 两个顶点落在了同样的索引上！<span class="subst">&#123;idx1&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exist_idx1 &amp;&amp; exist_idx2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateTriangleVert</span>(<span class="params"><span class="built_in">int</span> oldIdx, <span class="built_in">int</span> newIdx, <span class="built_in">int</span> triIdx</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> tri_vert_start = triIdx * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (triangle_contains_vert_dict[triIdx][<span class="number">0</span>] == oldIdx) &#123;</span><br><span class="line">        triangles[tri_vert_start] = newIdx;</span><br><span class="line">        triangle_contains_vert_dict[triIdx][<span class="number">0</span>] = newIdx;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (triangle_contains_vert_dict[triIdx][<span class="number">1</span>] == oldIdx) &#123;</span><br><span class="line">        triangles[tri_vert_start + <span class="number">1</span>] = newIdx;</span><br><span class="line">        triangle_contains_vert_dict[triIdx][<span class="number">1</span>] = newIdx;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (triangle_contains_vert_dict[triIdx][<span class="number">2</span>] == oldIdx) &#123;</span><br><span class="line">        triangles[tri_vert_start + <span class="number">2</span>] = newIdx;</span><br><span class="line">        triangle_contains_vert_dict[triIdx][<span class="number">2</span>] = newIdx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（4）-最后结束减面，去除不合法的顶点，返回新Mesh"><a href="#（4）-最后结束减面，去除不合法的顶点，返回新Mesh" class="headerlink" title="（4）.最后结束减面，去除不合法的顶点，返回新Mesh"></a>（4）.最后结束减面，去除不合法的顶点，返回新Mesh</h3><p>结束时先遍历顶点数组，刷新相关三角型关系，最后用合法的顶点与三角型组成新Mesh</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mesh <span class="title">EndSimplify</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete vertex not valid</span></span><br><span class="line">    <span class="built_in">int</span> vertNum = vertexs.Length;</span><br><span class="line">    List&lt;Vector3&gt; newVerts = <span class="keyword">new</span> List&lt;Vector3&gt;();</span><br><span class="line">    <span class="built_in">int</span> curOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; vertNum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vertex_valid[i]) &#123;</span><br><span class="line">            curOffset++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> newIdx = i - curOffset;</span><br><span class="line">        <span class="comment">// old idx is bigger，so no conflict</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> triIdx <span class="keyword">in</span> vertex_link_triangle_dict[i])</span><br><span class="line">        &#123;</span><br><span class="line">            UpdateTriangleVert(i, newIdx, triIdx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newVerts.Add(vertexs[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete un valid tris</span></span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; newTriangles = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="built_in">int</span> triIdxNum = triangles.Length;</span><br><span class="line">    <span class="built_in">int</span> triNum = triIdxNum / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> triIdx = <span class="number">0</span>; triIdx &lt; triNum; triIdx++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!triangle_valid[triIdx]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> tri_vert_start = triIdx * <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> v1 = triangles[tri_vert_start];</span><br><span class="line">        <span class="built_in">int</span> v2 = triangles[tri_vert_start + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">int</span> v3 = triangles[tri_vert_start + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        newTriangles.Add(v1);</span><br><span class="line">        newTriangles.Add(v2);</span><br><span class="line">        newTriangles.Add(v3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO : normals和uv的计算</span></span><br><span class="line">    mesh.vertices = newVerts.ToArray();</span><br><span class="line">    mesh.triangles = newTriangles.ToArray();</span><br><span class="line">    mesh.RecalculateBounds();</span><br><span class="line">    mesh.RecalculateNormals();</span><br><span class="line">    <span class="keyword">return</span> mesh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="1-4-目前减面存在的问题"><a href="#1-4-目前减面存在的问题" class="headerlink" title="1.4.目前减面存在的问题"></a>1.4.目前减面存在的问题</h2><p>首先， Heap的刷新目前有些问题，现在还未在每次去除顶点对时更新堆内其他相连顶点对的误差值，所以算法进行的不完整，减面效果未达到预期，后续把这部分补上。</p>
<p>其次，上述步骤仅计算了Mesh的vertex和triangle关系，normal和uv均未设置，得到的Mesh也无法正确应用地貌贴图。</p>
<p>最后，目前的减面效果还存在一些问题，以下Mesh是某次减面操作中出现的：</p>
<figure>
    <img src="/images/Chapter05/MeshReduce_Problem.png" width="350" height="350" alt="image">
    <figcaption>图：Mesh减面目前存在的问题</figcaption>
</figure>


<p>可以看到上面的顶点中有些三角型重合了，说明计算过程中的顶点对维护依然存在问题，这对于后续Mesh的构建并不利。</p>
<p>最近这段时间一边忙着毕设论文一边做地图包更新，还阅读地形减面相关资料的同时还要读论文，所以代码维护上有些力不从心，后续再补上本节所说的各种问题，同时讲讲最近思考的地形优化思路</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>

  









    </main>

    <footer class="site-footer">
  <p class="site-info">
    希望哪天能做完我的游戏， Github : <a href="https://github.com/huayuxingtguiyujing/" target="_blank">huayuxingtguiyujing</a> and
    Theme : <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2025 huayuxingtguiyujing
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>